[{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"abtract","dir":"Articles","previous_headings":"","what":"Abtract","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Random Forests (Leo Breiman 2001) (RF) non-parametric statistical method requiring distributional assumptions covariate relation response. RF robust, nonlinear technique optimizes predictive accuracy fitting ensemble trees stabilize model estimates. package (Ishwaran Kogalur 2014) unified treatment Breiman’s random forests survival, regression classification problems. Predictive accuracy make RF attractive alternative parametric models, though complexity interpretability forest hinder wider application method. introduce package, tools visually understand random forest models grown R ( Core Team 2014) package. package structured extract intermediate data objects objects generates figures using (Wickham 2009) graphics package document structured tutorial building random forests regression package using package investigating forest constructed. investigate Boston Housing data Belsley, Kuh, Welsch (1980). demonstrate random forest variable selection using Variable Importance (VIMP) (Leo Breiman 2001) Minimal Depth (Ishwaran et al. 2010), property derived construction tree within forest. also demonstrate use variable dependence plots (Friedman 2000) aid interpretation RF results. examine variable interactions covariates using minimal depth interactions, conditional variable dependence plots. goal exercise demonstrate strength using Random Forest methods prediction information retrieval regression settings.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"about-this-document","dir":"Articles","previous_headings":"","what":"About this document","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"document package vignette package “Visually Exploring Random Forests” (https://cran.r-project.org/package=ggRandomForests). package designed use package (https://cran.r-project.org/package=randomForestSRC) (Ishwaran Kogalur 2014) growing random forests survival (time event response), regression (continuous response) classification (categorical response) settings uses package (https://cran.r-project.org/package=ggplot2) (Wickham 2009) plotting diagnostic variable association results. structured extract data objects objects provides functions printing plotting objects. vignette tutorial using package package building post-processing random forests regression settings. tutorial, explore random forest regression model constructed Boston housing data set Belsley, Kuh, Welsch (1980), available MASS package (Venables Ripley 2002). grow random forest demonstrate can used determining response depends predictive variables within model. tutorial demonstrates design usage many functions features also modify customize resulting ggplot graphic objects along way. vignette written using knitr package (https://cran.r-project.org/package=knitr]Xie (2013), facilitates weaving R ( Core Team 2014) code, results figures document text. Throughout document, R code displayed code blocks shown . code block loads R packages required run source code listed code blocks throughout remainder document. vignette available within package Comprehensive R Archive Network (CRAN) (https://www.r-project.org) ( Core Team 2014). package installed, vignette can viewed directly within R following command: development version package also available GitHub (https://github.com). invite comments, feature requests bug reports package (https://github.com/ehrlinger/ggRandomForests).","code":"> ################## Load packages ################## > library(\"ggplot2\")         # Graphics engine > library(\"RColorBrewer\")    # Nice color palettes > library(\"plotly\")          # for 3d surfaces.  > library(\"dplyr\")           # Better data manipulations > library(\"tidyr\")           # gather variables into long format > library(\"parallel\")        # mclapply for multicore processing >  > # Analysis packages. > library(\"randomForestSRC\") # random forests for survival, regression and  > # classification > library(\"ggRandomForests\") # ggplot2 random forest figures (This!) >  > ################ Default Settings ################## > theme_set(theme_bw())     # A ggplot2 theme with white background >  > ## Set open circle for censored, and x for events  > event_marks <- c(1, 4) > event_labels <- c(FALSE, TRUE) >  > ## We want red for death events, so reorder this set. > str_col <- brewer.pal(3, \"Set1\")[c(2, 1, 3)] > vignette(\"randomForestSRC-Regression\", package = \"ggRFVignette\")"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Random Forests (Leo Breiman 2001) (RF) fully non-parametric statistical method requires distributional functional assumptions covariate relation response. RF robust, nonlinear technique optimizes predictive accuracy fitting ensemble trees stabilize model estimates. Random Survival Forests (RSF) Ishwaran et al. (2008) extension Breiman’s RF techniques survival settings, allowing efficient non-parametric analysis time event data. package (Ishwaran Kogalur 2014) unified treatment Breiman’s random forests survival (time event response), regression (continuous response) classification (categorical response) problems. Predictive accuracy make RF attractive alternative parametric models, though complexity interpretability forest hinder wider application method. introduce package visually exploring random forest models. package structured extract intermediate data objects objects generate figures using graphics package (Wickham 2009). Many figures created package also available directly within package. However offers following advantages: Separation data figures: contains functions operate either randomForestSRC::rfsrc forest object directly, output post processing functions (.e. plot.variable, var.select, find.interaction) generate intermediate data objects. Functions provide process objects plot results using graphics package. Alternatively, users can use data objects custom plotting analysis operations. data object/figure single, self contained object. allows simple modification manipulation data objects meet users specific needs requirements. use plotting. chose use package figures allow users flexibility modifying figures liking. plot function returns either single ggplot object, list ggplot objects, allowing users use additional functions themes modify customize figures liking. document formatted tutorial using package building post-processing random forest models package investigating forest constructed. tutorial, use Boston Housing Data (), available MASS package (Venables Ripley 2002), build random forest regression () demonstrate tools package examining forest construction. Random forests parsimonious, use variables available construction response predictor. demonstrate random forest variable selection () process using Variable Importance () measure (VIMP) (Leo Breiman 2001) well Minimal Depth () (Ishwaran et al. 2010), property derived construction tree within forest, assess impact variables forest prediction. idea variables want investigate , use variable dependence plots (Friedman 2000) understand variable related response. Marginal variable dependence () plots give us idea overall trend variable/response relation, partial dependence () plots show us risk adjusted relation. figures may show strongly non-linear variable/response relations easily obtained parametric approach. also interested examining variable interactions () within forest model. Using minimal depth approach, can quantify closely variables related within forest, generate marginal dependence coplots() partial dependence coplots () (risk adjusted) conditioning plots (coplots) Cleveland (1993) examine interactions graphically.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"data-boston-housing-values","dir":"Articles","previous_headings":"","what":"Data: Boston Housing Values","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Boston Housing data standard benchmark data set regression models. contains data 506 census tracts Boston 1970 census Belsley, Kuh, Welsch (1980). data available multiple R packages, keep installation dependencies package , use data contained MASS package (https://cran.r-project.org/package=MASS) (Venables Ripley 2002), available base install R. following code block loads data environment. include table Boston data set variable names, types descriptions reference interpret model results. Boston housing data dictionary. main objective Boston Housing data investigate variables associated predicting median value homes (continuous medv response) within 506 suburban areas Boston.","code":"> # Load the Boston Housing data > data(Boston, package = \"MASS\") >  > # Set modes correctly. For binary variables: transform to logical > Boston$chas <- as.logical(Boston$chas)"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"exploratory-data-analysis","dir":"Articles","previous_headings":"Data: Boston Housing Values","what":"Exploratory Data Analysis","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"good practice view data beginning analysis, (Tukey 1977) refers Exploratory Data Analysis (EDA). facilitate , use figures ggplot2::facet_wrap command create two sets panel plots, one categorical variables boxplots level, one scatter plots continuous variables. variable plotted along selected continuous variable X-axis. figures help find outliers, missing values data anomalies variable getting deep analysis. also created separate shiny app (https://shiny.posit.co/) (Chang et al. 2015), available (https://ehrlinger.shinyapps.io/xportEDA), creating similar figures arbitrary data set, make EDA process easier users. Boston housing data consists almost entirely continuous variables, exception “Charles river” logical variable. simple EDA visualization use data single panel plot continuous variables, observation points colored logical variable. Missing values continuous variable plots indicated rug marks along x-axis, none data. used Boston housing response variable, median value homes (medv), X variable. EDA variable plots. Points indicate variable value median home value variable. Points colored according chas variable. figure loosely related pairs scatter plot (Becker, Chambers, Wilks 1988), case examine relation response variable remainder. Plotting data response also gives us “sanity check” viewing model results. ’s pretty obvious figure find strong relation median home values lstat rm variables.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"random-forest---regression","dir":"Articles","previous_headings":"","what":"Random Forest - Regression","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Random Forest grown bagging (L. Breiman 1996a) collection classification regression trees (CART) (L. Breiman et al. 1984). method uses set BB bootstrap (Efron Tibshirani 1994) samples, growing independent tree model sub-sample population. tree grown recursively partitioning population based optimization split rule pp-dimensional covariate space. split, subset m≤pm \\le p candidate variables tested split rule optimization, dividing node two daughter nodes. daughter node split process reaches stopping criteria either node purity node member size, defines set terminal (unsplit) nodes tree. regression trees, split rule based minimizing mean squared error, whereas classification problems, Gini index used (Friedman 2000). Random Forests sort training set observation one unique terminal node per tree. Tree estimates observation constructed terminal node, among terminal node members. Random Forest estimate observation calculated aggregating, averaging (regression) votes (classification), terminal node results across collection BB trees. tutorial, grow random forest regression using rfsrc command predict median home value (medv variable) using remaining 13 independent predictor variables. example use default set B=1000B=1000 trees (ntree argument), m=5m=5 candidate variables (mtry) split stopping criteria nodesize=5 observations within terminal node. growing random forests computationally expensive, package targeted visualization random forest objects, use cached copies objects throughout document. include cached objects data sets package. actual rfsrc calls included comments within code blocks. randomForestSRC::print.rfsrc summary details parameters used rfsrc call described , returns variance generalization error estimate forest training set. forest built 506 observations 13 independent variables. constructed continuous medv variable using ntree=1000 regression (regr) trees, randomly selecting 5 candidate variables node split, terminating nodes fewer 5 observations.","code":"> # Load the data, from the call: > rfsrc_boston <- rfsrc(medv ~ ., data = Boston,  +                       importance = TRUE, err.block = 5) >  > # print the forest summary > rfsrc_boston"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"generalization-error-estimates","dir":"Articles","previous_headings":"Random Forest - Regression","what":"Generalization error estimates","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"One advantage Random Forests built generalization error estimate. bootstrap sample selects approximately 63.2% population average. remaining 36.8% observations, --Bag (OOB) (L. Breiman 1996b) sample, can used hold test set trees forest. OOB prediction error estimate can calculated observation predicting response set trees trained particular observation. --Bag prediction error estimates shown nearly identical n–fold cross validation estimates (Hastie, Tibshirani, Friedman 2009). feature Random Forests allows us obtain model fit validation one pass algorithm. gg_error function operates randomForestSRC::rfsrc object extract error estimates forest grown. code block demonstrates part design philosophy, create separate data objects provide functions operate data objects. following code block first creates gg_error object, uses plot.gg_error function create ggplot object display. Random forest generalization error. OOB error convergence along number trees forest. figure demonstrates take large number trees stabilize forest prediction error estimate. However, ensure variable enough chance included forest prediction process, want create rather large random forest trees.","code":"> # Plot the OOB errors against the growth of the forest. > gg_e <- gg_error(rfsrc_boston) > gg_e <- gg_e %>% filter(!is.na(error)) > class(gg_e) <- c(\"gg_error\", class(gg_e)) > plot(gg_e)"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"random-forest-prediction","dir":"Articles","previous_headings":"Random Forest - Regression","what":"Random Forest Prediction","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"gg_rfsrc function extracts OOB prediction estimates random forest. code block executes data extraction plotting one line, since interested holding prediction estimates later reuse. Also note add additional command (coord_cartesian) modify plot object. plot commands return ggplot objects, can also store modification reuse later analysis. OOB predicted median home values. Points jittered help visualize predictions observation. Boxplot indicates distribution predicted values. gg_rfsrc plot shows predicted median home value, one point observation training set. points jittered around single point x-axis, since looking predicted values forest. estimates Bag, analogous test set estimates. boxplot shown give indication distribution prediction estimates. analysis figure another model sanity check, interested exploring questions predictions.","code":"> # Plot predicted median home values. > plot(gg_rfsrc(rfsrc_boston), alpha = .5) + +   coord_cartesian(ylim = c(5, 49))"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"variable-selection","dir":"Articles","previous_headings":"","what":"Variable Selection","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Random forests parsimonious, use variables available construction response predictor. Also, unlike parametric models, Random Forests require explicit specification functional form covariates response. Therefore explicit p-value/significance test variable selection random forest model. Instead, RF ascertain variables contribute prediction split rule optimization, optimally choosing variables separate observations. use two separate approaches explore RF selection process, Variable Importance (\\autoref{variable-importance) Minimal Depth (\\autoref{minimal-depth).","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"variable-importance","dir":"Articles","previous_headings":"Variable Selection","what":"Variable Importance","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Variable importance (VIMP) originally defined CART using measure involving surrogate variables (see Chapter 5 (L. Breiman et al. 1984)). popular VIMP method uses prediction error approach involving “noising-” variable turn. VIMP variable xvx_v difference prediction error xvx_v noised randomly permuting values, compared prediction error observed values Ishwaran et al. (2008). Since VIMP difference OOB prediction error permutation, large VIMP value indicates misspecification detracts variable predictive accuracy forest. VIMP close zero indicates variable contributes nothing predictive accuracy, negative values indicate predictive accuracy improves variable misspecified. later case, assume noise informative true variable. , ignore variables negative near zero values VIMP, relying large positive values indicate predictive power forest dependent variables. gg_vimp function extracts VIMP measures variables used grow forest. plot.gg_vimp function shows variables, VIMP rank order, largest (Lower Status) top, smallest (Charles River) bottom. VIMP measures shown using bars compare scale error increase permutation. Random forest VIMP plot. Bars colored sign VIMP, longer blue bars indicate important variables. random forest, top two variables (lstat rm) largest VIMP, sizable difference remaining variables, mostly similar VIMP measure. indicates focus attention two variables, least, others. example, VIMP measures positive, though small. negative positive VIMP values, plot.gg_vimp function color VIMP sign measure. use lbls argument pass named vector meaningful text descriptions plot.gg_vimp function, replacing often terse variable names used default.","code":"> # Plot the VIMP rankings of independent variables. > plot(gg_vimp(rfsrc_boston), lbls = st_labs)"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"minimal-depth","dir":"Articles","previous_headings":"Variable Selection","what":"Minimal Depth","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"VIMP, prognostic risk factors determined testing forest prediction alternative data settings, ranking important variables according impact predictive ability forest. alternative method uses inspection forest construction rank variables. Minimal depth assumes variables high impact prediction frequently split nodes nearest trunks trees (.e. root node) partition large samples population. Within tree, node levels numbered based relative distance trunk tree (root 0). Minimal depth measures important risk factors averaging depth first split variable trees within forest. Lower values measure indicate variables important splitting large groups patients. maximal subtree variable xx largest subtree whose root node splits xx. parent nodes xx’s maximal subtree nodes split variables xx. largest maximal subtree possible root node. variable split root node, can one maximal subtree, maximal subtree may also exist splits variable. minimal depth variables surrogate measure predictiveness variable. smaller minimal depth, impact variable sorting observations, therefore forest prediction. gg_minimal_depth function analogous gg_vimp function minimal depth. Variables ranked important top (minimal depth measure), least bottom (maximal minimal depth). vertical dashed line indicates minimal depth threshold smaller minimal depth values indicate higher importance larger indicate lower importance. randomForestSRC::var.select call computationally intensive function, traverses forest finding maximal subtree within tree variable averaging results use gg_minimal_depth call. use cached object strategy save computational time. var.select call included comment code block. Minimal Depth variables rank order, important top. Vertical dashed line indicates maximal minimal depth important variables. general, selection variables according VIMP rather arbitrarily examine values, looking point along ranking large difference VIMP measures. minimal depth threshold method quantitative approach determine selection threshold. Given minimal depth quantitative property forest construction, (Ishwaran et al. 2010) also construct analytic threshold evidence variable impact. simple optimistic threshold rule uses mean minimal depth distribution, classifying variables minimal depth lower threshold important forest prediction. minimal depth plot model indicates ten variables higher impact (minimal depth mean value threshold) remaining three. Since VIMP Minimal Depth measures use different criteria, expect variable ranking somewhat different. use gg_minimal_vimp function compare rankings minimal depth VIMP. call, plot stored gg_minimal_depth object (gg_md), equivalent calling plot.gg_minimal_vimp(varsel_boston) plot(gg_minimal_vimp(varsel_boston)). Comparing Minimal Depth Vimp rankings. Points red dashed line ranked equivalently, points higher VIMP, higher minimal depth ranking. Variables colored sign VIMP measure. points along red dashed line indicates measures agreement. Points red dashed line ranked higher VIMP minimal depth, indicating variables sensitive misspecification. line higher minimal depth ranking, indicating better dividing large portions population. points line, discrepancy measures. construction figure skewed towards minimal depth approach, ranking variables along y-axis, though points colored sign VIMP. example, minimal depth VIMP indicate strong relation lstat rm variables forest prediction, agrees expectation Data: Boston Housing Values () done beginning document. now turn investigating , variables, related predicted response.","code":"> # Load the data, from the call: > varsel_boston <- var.select(rfsrc_boston) >  > # Save the gg_minimal_depth object for later use. > gg_md <- gg_minimal_depth(varsel_boston) >  > # plot the object > plot(gg_md, lbls = st_labs) > # gg_minimal_depth objects contain information about > # both minimal depth and VIMP. > plot(gg_minimal_vimp(gg_md))"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"responsevariable-dependence","dir":"Articles","previous_headings":"","what":"Response/Variable Dependence","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"random forests parsimonious methodology, can use minimal depth VIMP measures reduce number variables need examine manageable subset. like know forest response depends specific variables interest. often choose examine variables interest based study question, previous knowledge. absence , look variables contribute predictive accuracy forest. Although often characterized “black box” method, possible express random forest functional form. end forest predictor function, although complex, predictor variables f̂rf=f(x).\\hat{f}_{rf} = f(x). use graphical methods examine forest predicted response dependency covariates. two options, Variable Dependence () plots quick easy generate, Partial Dependence (\\autoref{partial-dependence) plots computationally intensive give us risk adjusted look dependence.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"variable-dependence","dir":"Articles","previous_headings":"Response/Variable Dependence","what":"Variable Dependence","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Variable dependence plots show predicted response function covariate interest, observation represented point plot. predicted point individual observations, dependent full combination covariates, covariate interest. Interpretation variable dependence plots can general terms, point predictions function covariates particular observation. However, variable dependence straight forward calculate, requiring predicted response observation. use gg_variable function call extract training set variables predicted OOB response randomForestSRC::rfsrc randomForestSRC::predict objects. following code block, store gg_variable data object later use, remaining variable dependence plots can constructed (gg_v) object. also use minimal depth selected variables (minimal depth lower threshold value) previously stored gg_minimal_depth object (gg_md$topvars) filter variables interest. plot.gg_variable function call operates gg_variable object. pass list variables interest (xvar) request single panel (panel=TRUE) display figures. default, plot.gg_variable function returns list ggplot objects, one figure variable named xvar argument. next three arguments passed internal ggplot plotting routines. se span arguments used modify internal call ggplot2::geom_smooth fitting smooth lines data. alpha argument lightens coloring points ggplot2::geom_point call, making easier see point plotting. also demonstrate modification plot labels using ggplot2::labs function. Variable dependence plot. Individual case predictions marked points. Loess smooth curve indicates trend variables increase shaded 95% confidence band. figure looks similar Data: Boston Housing Values (\\autoref{data-boston-housing-values) figure, although transposed axis plot response variable y-axis. closer panels match, better RF prediction. panels sorted match order variables xvar argument include smooth loess line Cleveland Devlin (1988), 95% shaded confidence band, indicates trend prediction dependence covariate values. convenient method panel scatter plots boxplots together, recommend creating panel plots variable type separately. Boston housing data contain single categorical variable, Charles river logical variable. Variable dependence plots categorical variables constructed using boxplots show distribution predictions within category. Although Charles river variable lowest importance scores VIMP minimal depth measures, include variable dependence plot example categorical variable dependence. Variable dependence Charles River logical variable. figure shows housing tracts border Charles river (chas=FALSE), comparing distributions predicted median housing values indicates significant difference home values. reinforces findings VIMP Minimal depth, Charles river variable little impact forest prediction median home values.","code":"> plot(gg_v, xvar = \"chas\", alpha = 0.4) + +   labs(y = st_labs[\"medv\"]) >  > # , points=FALSE, se=FALSE, notch=TRUE"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"partial-dependence","dir":"Articles","previous_headings":"Response/Variable Dependence","what":"Partial Dependence","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Partial variable dependence plots risk adjusted alternative variable dependence. Partial plots generated integrating effects variables beside covariate interest. Partial dependence data constructed selecting points evenly spaced along distribution XX variable interest. value (X=xX = x), calculate average RF prediction covariates XX f̃(x)=1n∑=1nf̂(x,xi,o), \\tilde{f}(x) = \\frac{1}{n} \\sum_{= 1}^n \\hat{f}(x, x_{, o}),  f̂\\hat{f} predicted response random forest xi,ox_{, o} value covariates X=xX = x observation ii(Friedman 2000). Essentially, average set predictions observation training set value X=xX=x. repeating process sequence X=xX=x values generate estimated points create partial dependence plot. Partial plots another computationally intensive analysis, especially large number observations. turn data caching strategy . default parameters randomForestSRC::plot.variable function generate partial dependence estimates npts=25 points (default value) along variable interest. point interest, plot.variable function averages n response predictions. repeated variables interest results returned later analysis. Partial dependence panels. Risk adjusted variable dependence variables minimal depth rank order. order panels minimal depth ranking. see lstat rm variables strongly related median value response, making partial dependence remaining variables look flat. also see strong nonlinearity two variables. lstat variable looks rather quadratic, rm shape complex. stop , indicating RF analysis found ten variables important predicting median home values. increasing lstat (percentage population lower status) values associated decreasing median home values (medv) increasing rm > 6 (number rooms >6> 6) associated increasing median home values. However, may also interested investigating variables work together help improve random forest prediction median home values.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"variable-interactions","dir":"Articles","previous_headings":"","what":"Variable Interactions","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Using different variable dependence measures, also possible calculate measures pairwise interactions among variables. Recall minimal depth measure defined averaging tree depth variable ii relative root node. detect interactions, calculation can modified measure minimal depth variable jj respect maximal subtree variable iiIshwaran et al. (2011). randomForestSRC::find.interaction function traverses forest, calculating pairwise minimal depth interactions, returns p×pp \\times p matrix interaction measures. row, diagonal terms related minimal depth relative root node, though normalized minimize scaling issues. diagonal minimal depth term relative diagonal term row. Small values indicate diagonal term typically splits close diagonal term, indicating forest split proximity two variables. gg_interaction function wraps find.interaction matrix use provided plot print functions. xvar argument indicates variables ’re interested looking . use cache strategy, collect figures together using panel=TRUE option. Minimal depth variable interactions. Reference variables marked red cross panel. Higher values indicate lower interactivity reference variable. plots interactions target variable (shown red cross) interaction scores remaining variables. expect covariate lowest minimal depth (lstat) associated almost variables, typically splits close root node, viewed alone may informative looking collection interactive depth plots. Scanning across panels, see successive target depth increasing, expected. also see interactive variables increasing increasing target depth. interest interaction lstat rm variable shown rm panel. Aside strongest variables measures, interactive measure indicates strongest connection variables.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"coplots","dir":"Articles","previous_headings":"","what":"Coplots","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Conditioning plots (coplots) Cleveland (1993) powerful visualization tool efficiently study response depends two variables (Cleveland 1993). method allows us view data grouping observations conditional membership. simplest example involves categorical variable, plot data conditional class membership, instance Charles river logical variable. can view coplot stratified variable dependence plot, indicating trends RF prediction results within panels group membership. Conditional membership continuous variable requires stratification level. Often can make stratification along feature variable, instance variable integer values, 5 10 year age group cohorts. However variables interest Boston housing example, “logical” stratification indications. Therefore arbitrarily stratify variables 6 groups roughly equal population size using quantile_pts function. pass break points located quantile_pts cut function create grouping intervals, can add gg_variable object plotting plot.gg_variable function. simple modification convert variable dependence plots condition variable dependence plots use ggplot2::facet_wrap command generate panel grouping interval. start examining predicted median home value function lstat conditional membership within 6 groups rm “intervals”. Variable Coplots. Predicted median home values function percentage lower status population, stratified average number rooms groups. point figure predicted median home value response plotted lstat value conditional rm interval specified. use smooth loess curve get idea trend within group. Overall, median values continue decrease increasing lstat, increases increasing rm. addition trends, can also examine conditional distribution variables. Note smaller homes (rm) high status (lower lstat) neighborhoods still high predicted median values, large homes higher status neighborhoods (bottom right panel). single coplot gives us grouped view variable (rm), along primary variable dimension (lstat). get better feel response depends variables, instructive look complement coplot. repeat previous coplot process, predicted median home value function rm variable, conditional membership within 6 groups lstat intervals. Variable Coplots. Predicted median home value function average number rooms, stratified percentage lower status groups. get similar information view, predicted median home values decrease increasing lstat percentage decreasing rm. However viewed together get better sense lstat rm variables work together (interact) median value prediction. Note typically (Cleveland 1993) conditional plots continuous variables included overlapping intervals along grouped variable. chose use mutually exclusive continuous variable intervals multiple reasons: Simplicity - can create coplot figures directly gg_variable object adding conditional group column directly object. Interpretability - find easier interpret compare panels observation single panel. Clarity - prefer using space data portion figures typically displayed coplot function available base R, require bar plot present overlapping segments. still possible augment gg_variable include overlapping conditional membership continuous variables duplicating rows object, setting correct conditional group membership. plot.gg_variable function recipe used generate panel plot, panels ordered according factor levels grouping variable. leave exercise reader.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"partial-dependence-coplots","dir":"Articles","previous_headings":"Coplots","what":"Partial dependence coplots","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"characterizing conditional plots stratified variable dependence plots, next logical step generate analogous conditional partial dependence plot. process similar variable dependence coplots, first determine conditional group membership, calculate partial dependence estimates subgroup using randomForestSRC::plot.variable function subset argument grouped interval. ggRandomForests::gg_partial_coplot function wrapper generating conditional partial dependence data object. Given random forest (randomForestSRC::rfsrc object) groups vector conditioning training data set observations, gg_partial_coplot calls randomForestSRC::plot.variable function set training set observations conditional groups membership. function returns gg_partial_coplot object, sub class gg_partial object, can plotted plot.gg_partial function. following code block generate data object creating partial dependence coplot predicted median home value function lstat conditional membership within 6 groups rm “intervals” examined previous section. Since gg_partial_coplot makes call randomForestSRC::plot.variable group (6) conditioning set, resort data caching strategy, load stored result data package. modify legend label indicate ’re working groups “Room” variable, use palette=\"Set1\" RColorBrewer package (Neuwirth 2014) choose nice color theme displaying six curves. Partial Coplots. Risk adjusted predicted median value function Lower Status, conditional groups average number rooms. Unlike variable dependence coplots, need use panel format partial dependence coplots looking risk adjusted estimates (points) instead population estimates. figure loess curve point estimates conditional rm interval groupings. figure indicates larger homes (rm 6.87 , shown yellow) higher median value others. neighborhoods higher lstat percentage, Median values decrease rm stabilizes intervals 5.73 6.47, decreases values smaller 5.73. lower lstat neighborhoods, effect smaller rm noticeable. can view partial coplot curves slices along surface viewed page, either along increasing decreasing rm values. made difficult choice select groups similar population size, curves evenly spaced along rm variable. return problem next section. also construct complement view, partial dependence coplot predicted median home value function rm conditional membership within 6 groups lstat “intervals”, cache following gg_partial_coplot data call, plot results plot.gg_variable call: Partial Coplots. Risk adjusted predicted median value function average number rooms, conditional groups percentage lower status population. figure indicates median home value change much rm increases 6.5, flattens 8, regardless lstat value. agrees well rm Partial Dependence (\\autoref{partial-dependence) plots shown earlier. , care must taken interpreting even spacing curves along percentage lstat groupings, , chose groups similar sized populations, evenly spaced along lstat variable.","code":"> partial_coplot_boston <- gg_partial_coplot(rfsrc_boston,  +                                            xvar = \"lstat\",  +                                            groups = rm_grp) > # Load the stored partial coplot data. >  > # # Partial coplot > ggplot(partial_coplot_boston, aes(x = lstat, y = yhat, col = group)) + +   geom_point() + +   geom_smooth(method = \"loess\", formula = \"y ~ x\", +               se = FALSE, alpha = 0.25) + +   labs(x = st_labs[\"lstat\"], y = st_labs[\"medv\"], +        color = \"Room\", shape = \"Room\") + +   scale_color_brewer(palette = \"Set1\") > partial_coplot_boston2 <- gg_partial_coplot(rfsrc_boston,  +                                             xvar = \"rm\",  +                                             groups = lstat_grp) > # Partial coplot > #plot(partial_coplot_boston2)+ ## again plot.gg_partial_coplot > ggplot(partial_coplot_boston2, aes(x = rm, y = yhat, col = group)) + +   geom_point() + +   geom_smooth(method = \"loess\", formula = \"y ~ x\", se = FALSE) + +   labs(x = st_labs[\"rm\"], y = st_labs[\"medv\"],  +        color = \"Lower Status\", shape = \"Lower Status\") + +   scale_color_brewer(palette = \"Set1\")"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"partial-plot-surfaces","dir":"Articles","previous_headings":"","what":"Partial plot surfaces","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"Visualizing two dimensional projections three dimensional data difficult, though tools available make data understandable. make interplay lower status average room size bit understandable, generate contour partial plot median home values. generate figure coplot data already , resolution bit strange. generate plot lstat conditional rm groupings, end contours grid lstat= 25×25 \\timesrm= 66, alternative rm conditional lstat groups, ’d transpose grid lstat= 6×6 \\timesrm= 2525. Since already using data caching strategy, generate another set gg_partial objects increased resolution lstat rm dimensions. exercise, find 50 points evenly spaced along rm variable values, generate partial plot curve point. partial plots, evaluate risk adjusted median home value npts=50 points along lstat variable. code block finds 50 rm values evenly spaced along distribution rm. use following data call generate partial plots randomForestSRC::plot.variable call. Within lapply call, use scope modify value rm variable within rfsrc_boston training set. Since values training set , averaged value rm places partial plot curve specific value rm. code block took 20 minutes run quad core Mac Air using single processor. cached data stored partial_boston_surf data set package. data set list 50 plot.variable objects. code block loads data, converts plot.variable objects gg_partial objects, attaches numeric values rm variable, generates contour plot.  Partial coplot contour plot. Contours median home value along lstat/rm plane. contours generated raw gg_partial estimation points, smooth curves shown Partial Dependence (\\autoref{partial-dependence) plots Partial Coplots (\\autoref{partial-dependence-coplots) figures previously. Contour lines, like topographic maps, concentrated slope surface large. use color indicate direction contour lines, lower median home values concentrated lower right hand corner, values increase along diagonal toward upper right. close contour lines indicate thing like step values 7 7.5 rooms, 5, 10 15% lstat. Contour plots still little difficult interpret. However, can also generate surface data using package (Soetaert 2014) plotly::plot_ly function. Viewed 3D, surface can help better understand contour lines showing us. figures reinforce previous findings, lower home values associated higher lstat percentage, higher values associated larger rm. difference figure can see predicted values change move around map lstat rm combinations. still need careful though, partial plots average values surface note supported actual observations.","code":"> # Find the quantile points to create 50 cut points > rm_pts <- quantile_pts(rfsrc_boston$xvar$rm,  +                        groups = 49, intervals = TRUE) > # Generate the gg_partial_coplot data object > system.time(partial_boston_surf <- lapply(rm_pts, function(ct) { +   rfsrc_boston$xvar$rm <- ct +   plot.variable(rfsrc_boston, xvar = \"lstat\", time = 1, +                 npts = 50, show.plots = TRUE,  +                 partial = TRUE) + })) > #     user   system  elapsed  > #    49.702   0.776  51.006"},{"path":"http://ehrlinger.github.io/ggRandomForests/articles/ggrfRegression.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"ggRandomForests: Exploring randomForestSRC Regression","text":"vignette, demonstrated use package explore regression random forest built package. shown create random forest () model determine variables contribute forest prediction accuracy using VIMP () Minimal Depth () measures. outlined investigate variable associations response variable using variable dependence () risk adjusted partial dependence () plots. ’ve also explored variable interactions using pairwise minimal depth interactions () directly viewed interactions using variable dependence coplots () partial dependence coplots (). Along way, ’ve demonstrated use additional commands package modifying customizing results .","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"John Ehrlinger. Author, maintainer.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ehrlinger J (2025). ggRandomForests: Visually Exploring Random Forests. R package version 2.4.0, https://cran.r-project.org/package=ggRandomForests.","code":"@Manual{,   title = {ggRandomForests: Visually Exploring Random Forests},   author = {John Ehrlinger},   url = {https://cran.r-project.org/package=ggRandomForests},   note = {R package version 2.4.0},   date = {2020-04-26},   year = {2025}, }"},{"path":"http://ehrlinger.github.io/ggRandomForests/index.html","id":"ggrandomforests-visually-exploring-random-forests","dir":"","previous_headings":"","what":"Visually Exploring Random Forests","title":"Visually Exploring Random Forests","text":"ggRandomForests help uncover variable associations random forests models. package designed use randomForest package (. Liaw M. Wiener 2002) randomForestSRC package (Ishwaran et.al. 2014, 2008, 2007) survival, regression classification random forests uses ggplot2 package (Wickham 2009) plotting diagnostic variable association results. ggRandomForests structured extract data objects randomForestSRC randomForest objects provides S3 functions printing plotting objects. randomForestSRC package provides unified treatment Breiman’s (2001) random forests variety data settings. Regression classification forests grown response numeric categorical (factor) survival competing risk forests (Ishwaran et al. 2008, 2012) grown right-censored survival data. Recently, support randomForest package (. Liaw M. Wiener 2002) regression classification forests also added. Many figures created ggRandomForests package also available directly within randomForestSRC randomForest package. However, ggRandomForests offers following advantages: Separation data figures: ggRandomForests contains functions operate either forest object directly, output randomForestSRC randomForest post processing functions (.e. plot.variable, var.select, find.interaction) generate intermediate ggRandomForests data objects. S3 functions provide process objects plot results using ggplot2 graphics package. Alternatively, users can use data objects additional custom plotting analysis operations. data object/figure single, self contained object. allows simple modification manipulation data ggplot2 objects meet users specific needs requirements. use ggplot2 plotting. chose use ggplot2 package figures allow users flexibility modifying figures liking. S3 plot function returns either single ggplot2 object, list ggplot2 objects, allowing users use additional ggplot2 functions themes modify customize figures liking. package recently extended Breiman Cutler’s Random Forests Classification Regression package randomForest possible. Though methods provided gg_* functions, unsupported functions return error message indicating support still lacking.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Visually Exploring Random Forests","text":"Breiman, L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2014). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.5.5. Ishwaran H. Kogalur U.B. (2007). Random survival forests R. R News 7(2), 25–31. Ishwaran H., Kogalur U.B., Blackstone E.H. Lauer M.S. (2008). Random survival forests. Ann. Appl. Statist. 2(3), 841–860. . Liaw M. Wiener (2002). Classification Regression randomForest. R News 2(3), 18–22. Wickham, H. ggplot2: elegant graphics data analysis. Springer New York, 2009.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_auc.html","id":null,"dir":"Reference","previous_headings":"","what":"Area Under the ROC Curve calculator — calc_auc","title":"Area Under the ROC Curve calculator — calc_auc","text":"Area ROC Curve calculator","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_auc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area Under the ROC Curve calculator — calc_auc","text":"","code":"calc_auc(x)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_auc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area Under the ROC Curve calculator — calc_auc","text":"x gg_roc object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_auc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area Under the ROC Curve calculator — calc_auc","text":"AUC. 50% random guessing, higher better.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_auc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Area Under the ROC Curve calculator — calc_auc","text":"calc_auc uses trapezoidal rule calculate area ROC curve. helper function gg_roc functions.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_auc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area Under the ROC Curve calculator — calc_auc","text":"","code":"## ## Taken from the gg_roc example rfsrc_iris <- rfsrc(Species ~ ., data = iris)  if (FALSE) { # \\dontrun{ gg_dta <- gg_roc(rfsrc_iris, which_outcome=1)  calc_auc(gg_dta) } # }  gg_dta <- gg_roc(rfsrc_iris, which_outcome=2)  calc_auc(gg_dta) #> [1] 1  ## randomForest tests rf_iris <- randomForest::randomForest(Species ~ ., data = iris) gg_dta <- gg_roc(rfsrc_iris, which_outcome=2)  calc_auc(gg_dta) #> [1] 1"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_roc.rfsrc.html","id":null,"dir":"Reference","previous_headings":"","what":"Receiver Operator Characteristic calculator — calc_roc.rfsrc","title":"Receiver Operator Characteristic calculator — calc_roc.rfsrc","text":"Receiver Operator Characteristic calculator","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_roc.rfsrc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Receiver Operator Characteristic calculator — calc_roc.rfsrc","text":"","code":"# S3 method for class 'rfsrc' calc_roc(object, dta, which_outcome = \"all\", oob = TRUE, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_roc.rfsrc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Receiver Operator Characteristic calculator — calc_roc.rfsrc","text":"object rfsrc predict.rfsrc object containing predicted response dta True response variable which_outcome defined, show ROC response. oob Use OOB estimates, normal validation method (TRUE) ... extra arguments passed helper functions","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_roc.rfsrc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Receiver Operator Characteristic calculator — calc_roc.rfsrc","text":"gg_roc object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_roc.rfsrc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Receiver Operator Characteristic calculator — calc_roc.rfsrc","text":"randomForestSRC prediction actual response value, calculate specificity (1-False Positive Rate) sensitivity (True Positive Rate) predictor. helper function gg_roc functions, intended use end user.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/calc_roc.rfsrc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Receiver Operator Characteristic calculator — calc_roc.rfsrc","text":"","code":"## Taken from the gg_roc example rfsrc_iris <- rfsrc(Species ~ ., data = iris)  gg_dta <- calc_roc(rfsrc_iris, rfsrc_iris$yvar,      which_outcome=1, oob=TRUE) gg_dta <- calc_roc(rfsrc_iris, rfsrc_iris$yvar,      which_outcome=1, oob=FALSE)  rf_iris <- randomForest(Species ~ ., data = iris) gg_dta <- calc_roc(rf_iris, rf_iris$yvar,      which_outcome=1) gg_dta <- calc_roc(rf_iris, rf_iris$yvar,      which_outcome=2)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/combine.gg_partial.html","id":null,"dir":"Reference","previous_headings":"","what":"combine two gg_partial objects — combine.gg_partial","title":"combine two gg_partial objects — combine.gg_partial","text":"combine.gg_partial function assumes two gg_partial objects generated rfsrc object. , function joins along gg_partial list item names (one per partial plot variable). , combine two gg_partial objects along group variable. Hence, join three gg_partial objects together (.e. three different time points survival random forest) require two combine.gg_partial calls: One join first two gg_partial object, one append third gg_partial object output first call. second call append single lbls label gg_partial object.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/combine.gg_partial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"combine two gg_partial objects — combine.gg_partial","text":"","code":"combine.gg_partial(x, y, lbls, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/combine.gg_partial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"combine two gg_partial objects — combine.gg_partial","text":"x gg_partial  object y gg_partial  object lbls vector 2 strings label combined data. ... used","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/combine.gg_partial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"combine two gg_partial objects — combine.gg_partial","text":"gg_partial gg_partial_list based  class x y.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/combine.gg_partial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"combine two gg_partial objects — combine.gg_partial","text":"","code":"if (FALSE) { # \\dontrun{ # We need to create this dataset data(pbc, package = \"randomForestSRC\",)  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE ) xvar <- c(\"bili\", \"albumin\", \"copper\", \"prothrombin\", \"age\") xvar_cat <- c(\"edema\") xvar <- c(xvar, xvar_cat)  time_index <- c(which(rfsrc_pbc$time.interest > 1)[1] - 1,                   which(rfsrc_pbc$time.interest > 3)[1] - 1,                   which(rfsrc_pbc$time.interest > 5)[1] - 1)                  partial_pbc <- mclapply(rfsrc_pbc$time.interest[time_index],                   function(tm) {                     plot.variable(rfsrc_pbc, surv.type = \"surv\",                                         time = tm, xvar.names = xvar,                                        partial = TRUE,                                         show.plots = FALSE)                        })                         # A list of 2 plot.variable objects length(partial_pbc) class(partial_pbc)  class(partial_pbc[[1]]) class(partial_pbc[[2]])  # Create gg_partial objects ggPrtl.1 <- gg_partial(partial_pbc[[1]]) ggPrtl.2 <- gg_partial(partial_pbc[[2]])  # Combine the objects to get multiple time curves # along variables on a single figure. ggpart <- combine.gg_partial(ggPrtl.1, ggPrtl.2,                              lbls = c(\"1 year\", \"3 years\"))  # Plot each figure separately plot(ggpart)  # Get the continuous data for a panel of continuous plots. ggcont <- ggpart ggcont$edema <- ggcont$ascites <- ggcont$stage <- NULL plot(ggcont, panel=TRUE)  # And the categorical for a panel of categorical plots. nms <- colnames(sapply(ggcont, function(st) {st})) for(ind in nms) {    ggpart[[ind]] <- NULL } plot(ggpart, panel=TRUE)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/ggRandomForests-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ggRandomForests: Visually Exploring Random Forests — ggRandomForests-package","title":"ggRandomForests: Visually Exploring Random Forests — ggRandomForests-package","text":"ggRandomForests utility package randomForestSRC (Ishwaran et.al. 2014, 2008, 2007) survival, regression classification forests uses ggplot2 (Wickham 2009) package plotting results. ggRandomForests structured extract data objects random forest provides S3 functions printing plotting objects. randomForestSRC package provides unified treatment Breiman's (2001) random forests variety data settings. Regression classification forests grown response numeric categorical (factor) survival competing risk forests (Ishwaran et al. 2008, 2012) grown right-censored survival data. Many figures created ggRandomForests package also available directly within randomForestSRC package. However, ggRandomForests offers following advantages: Separation data figures: ggRandomForest contains functions operate either rfsrc forest object directly, output randomForestSRC post processing functions (.e. plot.variable, var.select, find.interaction) generate intermediate ggRandomForests data objects. S3 functions provide process objects plot results using ggplot2 graphics package. Alternatively, users can use data objects additional custom plotting analysis operations. data object/figure single, self contained object. allows simple modification manipulation data ggplot2 objects meet users specific needs requirements. use ggplot2 plotting. chose use ggplot2 package figures allow users flexibility modifying figures liking. S3 plot function returns either single ggplot2 object, list ggplot2 objects, allowing users use additional ggplot2 functions themes modify customize figures liking. ggRandomForests package contains following data functions: gg_rfsrc: randomForest[SRC] predictions. gg_error: randomForest[SRC] convergence rate based OOB error rate. gg_roc: ROC curves randomForest classification models. gg_vimp: Variable Importance ranking variable selection. gg_minimal_depth: Minimal Depth ranking variable selection (Ishwaran et.al. 2010). gg_minimal_vimp: Comparing Minimal Depth VIMP rankings variable selection. gg_interaction: Minimal Depth interaction detection (Ishwaran et.al. 2010) gg_variable: Marginal variable dependence. gg_partial: Partial (risk adjusted) variable dependence. gg_partial_coplot: Partial variable conditional dependence (computationally expensive). gg_survival: Kaplan-Meier/Nelson-Aalen hazard analysis. data functions associated S3 plot function returns ggplot2 objects, either individually list, can customized using standard ggplot2 commands.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/ggRandomForests-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"ggRandomForests: Visually Exploring Random Forests — ggRandomForests-package","text":"Breiman, L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2014). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.5.5.12. Ishwaran H. Kogalur U.B. (2007). Random survival forests R. R News 7(2), 25–31. Ishwaran H., Kogalur U.B., Blackstone E.H. Lauer M.S. (2008). Random survival forests. Ann. Appl. Statist. 2(3), 841–860. Ishwaran, H., U. B. Kogalur, E. Z. Gorodeski, . J. Minn, M. S. Lauer (2010). High-dimensional variable selection survival data. J. Amer. Statist. Assoc. 105, 205-217. Ishwaran, H. (2007). Variable importance binary regression trees forests. Electronic J. Statist., 1, 519-537. Wickham, H. ggplot2: elegant graphics data analysis. Springer New York, 2009.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_error.html","id":null,"dir":"Reference","previous_headings":"","what":"randomForest error rate data object — gg_error","title":"randomForest error rate data object — gg_error","text":"Extract cumulative (OOB) randomForestSRC error rate function number trees.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"randomForest error rate data object — gg_error","text":"","code":"gg_error(object, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"randomForest error rate data object — gg_error","text":"object rfsrc object. ... optional arguments (used).","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"randomForest error rate data object — gg_error","text":"gg_error data.frame one column indicating tree number, remaining columns rfsrc$err.rate return value.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_error.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"randomForest error rate data object — gg_error","text":"gg_error function simply returns rfsrc$err.rate object data.frame, assigns class connecting S3 plot.gg_error function.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_error.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"randomForest error rate data object — gg_error","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"randomForest error rate data object — gg_error","text":"","code":"## Examples from RFSRC package... ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## ------------- iris data ## You can build a randomForest rfsrc_iris <- rfsrc(Species ~ ., data = iris, tree.err = TRUE)  # Get a data.frame containing error rates gg_dta <- gg_error(rfsrc_iris)  # Plot the gg_error object plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 4 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## RandomForest example rf_iris <- randomForest::randomForest(Species ~ ., data = iris,                                        tree.err = TRUE, ) gg_dta <- gg_error(rf_iris) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 2000 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   gg_dta <- gg_error(rf_iris, training=TRUE) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 2000 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.  ## ------------------------------------------------------------ ## Regression example ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## ------------- airq data rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality,      na.action = \"na.impute\", tree.err = TRUE, )  # Get a data.frame containing error rates gg_dta <- gg_error(rfsrc_airq)  # Plot the gg_error object plot(gg_dta) } # }  ## ------------- Boston data data(Boston, package = \"MASS\") Boston$chas <- as.logical(Boston$chas) rfsrc_boston <- rfsrc(medv ~ .,    data = Boston,    forest = TRUE,    importance = TRUE,    tree.err = TRUE,    save.memory = TRUE)  # Get a data.frame containing error rates gg_dta<- gg_error(rfsrc_boston)  # Plot the gg_error object plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 50 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   if (FALSE) { # \\dontrun{ ## ------------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars, tree.err = TRUE) # Get a data.frame containing error rates gg_dta<- gg_error(rfsrc_mtcars)  # Plot the gg_error object plot(gg_dta) } # }  ## ------------------------------------------------------------ ## Survival example ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## ------------- veteran data ## randomized trial of two treatment regimens for lung cancer data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ ., data = veteran,                        tree.err = TRUE)  gg_dta <- gg_error(rfsrc_veteran) plot(gg_dta)  ## ------------- pbc data # Load a cached randomForestSRC object # We need to create this dataset data(pbc, package = \"randomForestSRC\",)  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  tree.err = TRUE,   forest = TRUE,  importance = TRUE,  save.memory = TRUE )   gg_dta <- gg_error(rfsrc_pbc) plot(gg_dta) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_interaction.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimal Depth Variable Interaction data object (find.interaction). — gg_interaction","title":"Minimal Depth Variable Interaction data object (find.interaction). — gg_interaction","text":"Converts matrix returned find.interaction data.frame add attributes S3 identification. passed  rfsrc object, gg_interaction first runs find.interaction function optional arguments.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_interaction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimal Depth Variable Interaction data object (find.interaction). — gg_interaction","text":"","code":"gg_interaction(object, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_interaction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimal Depth Variable Interaction data object (find.interaction). — gg_interaction","text":"object rfsrc object output find.interaction function call. ... optional extra arguments passed find.interaction.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_interaction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimal Depth Variable Interaction data object (find.interaction). — gg_interaction","text":"gg_interaction object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_interaction.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Minimal Depth Variable Interaction data object (find.interaction). — gg_interaction","text":"Ishwaran H. (2007). Variable importance binary regression trees forests, Electronic J. Statist., 1:519-537. Ishwaran H., Kogalur U.B., Gorodeski E.Z, Minn .J. Lauer M.S. (2010). High-dimensional variable selection survival data. J. Amer. Statist. Assoc., 105:205-217. Ishwaran H., Kogalur U.B., Chen X. Minn .J. (2011). Random survival forests high-dimensional data. Statist. Anal. Data Mining, 4:115-132.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_interaction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimal Depth Variable Interaction data object (find.interaction). — gg_interaction","text":"","code":"## Examples from randomForestSRC package... ## ------------------------------------------------------------ ## find interactions, classification setting ## ------------------------------------------------------------ ## -------- iris data iris.obj <- rfsrc(Species ~., data = iris) ## TODO: VIMP interactions not handled yet.... ## randomForestSRC::find.interaction(iris.obj, method = \"vimp\", nrep = 3)  interaction_iris <- randomForestSRC::find.interaction(iris.obj) #>  #>                               Method: maxsubtree #>                     No. of variables: 4 #>   Variables sorted by minimal depth?: TRUE #>  #>              Petal.Width Petal.Length Sepal.Length Sepal.Width #> Petal.Width         0.15         0.45         0.62        0.68 #> Petal.Length        0.49         0.20         0.64        0.66 #> Sepal.Length        0.70         0.69         0.48        0.78 #> Sepal.Width         0.85         0.83         0.87        0.64 gg_dta <- gg_interaction(interaction_iris)  plot(gg_dta, xvar=\"Petal.Width\") #> Warning: All aesthetics have length 1, but the data has 4 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.  plot(gg_dta, panel=TRUE) #> Warning: All aesthetics have length 1, but the data has 16 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 4 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## ------------------------------------------------------------ ## find interactions, regression setting ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- air quality data airq.obj <- rfsrc(Ozone ~ ., data = airquality) ## ## TODO: VIMP interactions not handled yet.... ## randomForestSRC::find.interaction(airq.obj, method = \"vimp\", nrep = 3) interaction_airq <- randomForestSRC::find.interaction(airq.obj)  gg_dta <- gg_interaction(interaction_airq)  plot(gg_dta, xvar=\"Temp\") plot(gg_dta, xvar=\"Solar.R\")  plot(gg_dta, panel=TRUE) } # } if (FALSE) { # \\dontrun{ ## -------- Boston data data(Boston, package = \"MASS\") Boston$chas <- as.logical(Boston$chas) rfsrc_boston <- rfsrc(medv ~ .,    data = Boston,    forest = TRUE,    importance = TRUE,    tree.err = TRUE,    save.memory = TRUE)     interaction_boston <- find.interaction(rfsrc_boston)  gg_dta <- gg_interaction(interaction_boston)  plot(gg_dta, panel=TRUE) } # } if (FALSE) { # \\dontrun{ ## -------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars)  interaction_mtcars <- find.interaction(rfsrc_mtcars)  gg_dta <- gg_interaction(interaction_mtcars)  plot(gg_dta, panel=TRUE) } # } if (FALSE) { # \\dontrun{ ## ------------------------------------------------------------ ## find interactions, survival setting ## ------------- veteran data ## randomized trial of two treatment regimens for lung cancer data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ ., data = veteran)  interaction_vet <- find.interaction(rfsrc_veteran)  gg_dta <- gg_interaction(interaction_vet)  plot(gg_dta, panel = True)  ## ------------------------------------------------------------ ## -------- pbc data # We need to create this dataset data(pbc, package = \"randomForestSRC\",)  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } # Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  interaction_pbc <- find.interaction(rfsrc_pbc, nvar = 9) gg_dta <- gg_interaction(interaction_pbc)  plot(gg_dta, xvar=\"bili\") plot(gg_dta, panel=TRUE)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimal depth data object ([randomForestSRC]{var.select}) — gg_minimal_depth","title":"Minimal depth data object ([randomForestSRC]{var.select}) — gg_minimal_depth","text":"[randomForestSRC]{var.select} function implements random forest variable selection using tree minimal depth methodology. gg_minimal_depth function takes output [randomForestSRC]{var.select} creates data.frame formatted plot.gg_minimal_depth function.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimal depth data object ([randomForestSRC]{var.select}) — gg_minimal_depth","text":"","code":"gg_minimal_depth(object, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimal depth data object ([randomForestSRC]{var.select}) — gg_minimal_depth","text":"object [randomForestSRC]{rfsrc} object, [randomForestSRC]{predict} object list [randomForestSRC]{var.select.rfsrc} function. ... optional arguments passed [randomForestSRC]{var.select} function operating [randomForestSRC]{rfsrc} object.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_depth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimal depth data object ([randomForestSRC]{var.select}) — gg_minimal_depth","text":"gg_minimal_depth object, modified list variables [randomForestSRC]{var.select} function, ordered minimal depth rank.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimal depth data object ([randomForestSRC]{var.select}) — gg_minimal_depth","text":"","code":"## Examples from RFSRC package... ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data ## You can build a randomForest rfsrc_iris <- rfsrc(Species ~ ., data = iris) varsel_iris <- randomForestSRC::var.select(rfsrc_iris) #> minimal depth variable selection ... #>  #>  #> ----------------------------------------------------------- #> family             : class  #> var. selection     : Minimal Depth  #> conservativeness   : medium  #> x-weighting used?  : TRUE  #> dimension          : 4  #> sample size        : 150  #> ntree              : 500  #> nsplit             : 10  #> mtry               : 2  #> nodesize           : 1  #> refitted forest    : FALSE  #> model size         : 2  #> depth threshold    : 2.1443  #> PE (true OOB)      : 0.0467 0.02 0.06 0.06  #>  #>  #> Top variables: #>              depth vimp #> Petal.Width  0.804   NA #> Petal.Length 1.108   NA #> -----------------------------------------------------------  # Get a data.frame containing minimaldepth measures gg_dta <- gg_minimal_depth(varsel_iris)  # Plot the gg_minimal_depth object plot(gg_dta) #> Coordinate system already present. Adding new coordinate system, which will #> replace the existing one. #> Warning: All aesthetics have length 1, but the data has 4 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## ------------------------------------------------------------ ## Regression example ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- air quality data rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality,                      na.action = \"na.impute\") varsel_airq <- var.select(rfsrc_airq)  # Get a data.frame containing error rates gg_dta<- gg_minimal_depth(varsel_airq)  # Plot the gg_minimal_depth object plot(gg_dta) } # } if (FALSE) { # \\dontrun{  ## -------- Boston data data(Boston, package = \"MASS\") Boston$chas <- as.logical(Boston$chas) rfsrc_boston <- rfsrc(medv ~ .,    data = Boston,    forest = TRUE,    importance = TRUE,    tree.err = TRUE,    save.memory = TRUE)     varsel_boston <- var.select(rfsrc_boston)  # Get a data.frame containing error rates gg_dta <- gg_minimal_depth(varsel_boston) print(gg_dta) plot(gg_dta) } # } if (FALSE) { # \\dontrun{ ## -------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars) varsel_mtcars <- var.select(rfsrc_mtcars)  # Get a data.frame containing error rates plot.gg_minimal_depth(varsel_mtcars) } # }  ## ------------------------------------------------------------ ## Survival example ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- veteran data ## randomized trial of two treatment regimens for lung cancer data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ ., data = veteran, ntree = 100) varsel_veteran <- randomForestSRC::var.select(rfsrc_veteran)  gg_dta <- gg_minimal_depth(varsel_veteran) plot(gg_dta)  ## ------------------------------------------------------------ ## -------- pbc data # We need to create this dataset data(pbc, package = \"randomForestSRC\",)  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  varsel_pbc <- var.select(rfsrc_pbc)  gg_dta <- gg_minimal_depth(varsel_pbc) plot(gg_dta) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_vimp.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimal depth vs VIMP comparison by variable rankings. — gg_minimal_vimp","title":"Minimal depth vs VIMP comparison by variable rankings. — gg_minimal_vimp","text":"Minimal depth vs VIMP comparison variable rankings.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_vimp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimal depth vs VIMP comparison by variable rankings. — gg_minimal_vimp","text":"","code":"gg_minimal_vimp(object, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_vimp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimal depth vs VIMP comparison by variable rankings. — gg_minimal_vimp","text":"object rfsrc object, predict.rfsrc object list var.select.rfsrc function. ... optional arguments passed var.select function operating rfsrc object.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_vimp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimal depth vs VIMP comparison by variable rankings. — gg_minimal_vimp","text":"gg_minimal_vimp comparison object.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_minimal_vimp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimal depth vs VIMP comparison by variable rankings. — gg_minimal_vimp","text":"","code":"## Examples from RFSRC package... ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data ## You can build a randomForest rfsrc_iris <- rfsrc(Species ~ ., data = iris) varsel_iris <- randomForestSRC::var.select(rfsrc_iris) #> minimal depth variable selection ... #>  #>  #> ----------------------------------------------------------- #> family             : class  #> var. selection     : Minimal Depth  #> conservativeness   : medium  #> x-weighting used?  : TRUE  #> dimension          : 4  #> sample size        : 150  #> ntree              : 500  #> nsplit             : 10  #> mtry               : 2  #> nodesize           : 1  #> refitted forest    : FALSE  #> model size         : 2  #> depth threshold    : 2.1119  #> PE (true OOB)      : 0.04 0.02 0.06 0.04  #>  #>  #> Top variables: #>              depth vimp #> Petal.Width  0.906   NA #> Petal.Length 1.088   NA #> -----------------------------------------------------------  # Get a data.frame containing minimaldepth measures gg_dta<- gg_minimal_vimp(varsel_iris)  # Plot the gg_minimal_depth object plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 4 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## ------------------------------------------------------------ ## Regression example ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- air quality data rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality,                      na.action = \"na.impute\") varsel_airq <- randomForestSRC::var.select(rfsrc_airq)  # Get a data.frame containing error rates gg_dta<- gg_minimal_vimp(varsel_airq)  # Plot the gg_minimal_vimp object plot(gg_dta) } # } if (FALSE) { # \\dontrun{ ## -------- Boston data data(Boston, package = \"MASS\") Boston$chas <- as.logical(Boston$chas) rfsrc_boston <- rfsrc(medv ~ .,    data = Boston,    forest = TRUE,    importance = TRUE,    tree.err = TRUE,    save.memory = TRUE)     varsel_boston <- var.select(rfsrc_boston)  # Get a data.frame containing error rates gg_dta<- gg_minimal_vimp(varsel_boston)  # Plot the gg_minimal_vimp object plot(gg_dta) } # } if (FALSE) { # \\dontrun{ ## -------- mtcars data  rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars) varsel_mtcars <- var.select(rfsrc_mtcars)  # Get a data.frame containing error rates gg_dta <- gg_minimal_vimp(varsel_mtcars)  # Plot the gg_minimal_vimp object plot(gg_dta) } # } ## ------------------------------------------------------------ ## Survival example ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- veteran data ## randomized trial of two treatment regimens for lung cancer data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ ., data = veteran,                          ntree = 100) varsel_veteran <- randomForestSRC::var.select(rfsrc_veteran)  gg_dta <- gg_minimal_vimp(varsel_veteran) plot(gg_dta)   ## ------------------------------------------------------------ ## -------- pbc data # We need to create this dataset data(pbc, package = \"randomForestSRC\")  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  varsel_pbc <- var.select(rfsrc_pbc)   gg_dta <- gg_minimal_vimp(varsel_pbc) plot(gg_dta) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial.html","id":null,"dir":"Reference","previous_headings":"","what":"Partial variable dependence object — gg_partial","title":"Partial variable dependence object — gg_partial","text":"plot.variable function returns list either marginal variable dependence partial variable dependence data rfsrc object. gg_partial function formulates plot.variable output partial plots (partial=TRUE) data object creation partial dependence plots using plot.gg_partial function. Partial variable dependence plots risk adjusted estimates specified response function single covariate, possibly subsetted covariates. option named argument can name column merging multiple plots together","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partial variable dependence object — gg_partial","text":"","code":"gg_partial(object, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partial variable dependence object — gg_partial","text":"object partial variable dependence data object plot.variable function ... optional arguments","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partial variable dependence object — gg_partial","text":"gg_partial object. data.frame list data.frames corresponding variables contained within plot.variable output.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Partial variable dependence object — gg_partial","text":"Friedman, Jerome H. 2000. \"Greedy Function Approximation: Gradient Boosting Machine.\" Annals Statistics 29: 1189-1232.\"","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partial variable dependence object — gg_partial","text":"","code":"## ------------------------------------------------------------ ## classification ## ------------------------------------------------------------ ## -------- iris data ## iris \"Petal.Width\" partial dependence plot ## rfsrc_iris <- rfsrc(Species ~., data = iris) partial_iris <- plot.variable(rfsrc_iris,                                xvar.names = \"Petal.Width\",                               partial=TRUE)   gg_dta <- gg_partial(partial_iris) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 22 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## ------------------------------------------------------------ ## regression ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- air quality data ## airquality \"Wind\" partial dependence plot ## rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality) partial_airq <- plot.variable(rfsrc_airq,                                xvar.names = \"Wind\",                              partial=TRUE, show.plot=FALSE)  gg_dta <- gg_partial(partial_airq) plot(gg_dta)  } # } if (FALSE) { # \\dontrun{ ## -------- Boston data data(Boston, package = \"MASS\") Boston$chas <- as.logical(Boston$chas) rfsrc_boston <- rfsrc(medv ~ .,    data = Boston,    forest = TRUE,    importance = TRUE,    tree.err = TRUE,    save.memory = TRUE)     varsel_boston <- var.select(rfsrc_boston)  partial_boston <- plot.variable(rfsrc_boston,    xvar.names = varsel_boston$topvars,   sorted = FALSE,   partial = TRUE,    show.plots = FALSE) gg_dta <- gg_partial(partial_boston) plot(gg_dta, panel=TRUE) } # } if (FALSE) { # \\dontrun{ ## -------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars) varsel_mtcars <- var.select(rfsrc_mtcars)  partial_mtcars <- plot.variable(rfsrc_mtcars,    xvar.names = varsel_mtcars$topvars,   sorted = FALSE,   partial = TRUE,    show.plots = FALSE)  gg_dta <- gg_partial(partial_mtcars)  gg_dta.cat <- gg_dta gg_dta.cat[[\"disp\"]] <- gg_dta.cat[[\"wt\"]] <- gg_dta.cat[[\"hp\"]] <- NULL gg_dta.cat[[\"drat\"]] <- gg_dta.cat[[\"carb\"]] <- gg_dta.cat[[\"qsec\"]] <- NULL  plot(gg_dta.cat, panel=TRUE, notch=TRUE)  gg_dta[[\"cyl\"]] <- gg_dta[[\"vs\"]] <- gg_dta[[\"am\"]] <- NULL gg_dta[[\"gear\"]] <- NULL plot(gg_dta, panel=TRUE) } # }  ## ------------------------------------------------------------ ## survival examples ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- veteran data ## survival \"age\" partial variable dependence plot ##  data(veteran, package = \"randomForestSRC\")  rfsrc_veteran <- rfsrc(Surv(time,status)~., veteran, nsplit = 10,      ntree = 100)  varsel_rfsrc <- var.select(rfsrc_veteran)  ## 30 day partial plot for age partial_veteran <- plot.variable(rfsrc_veteran, surv.type = \"surv\",                                partial = TRUE, time=30,                                show.plots=FALSE)  gg_dta <- gg_partial(partial_veteran) plot(gg_dta, panel=TRUE)  gg_dta.cat <- gg_dta gg_dta[[\"celltype\"]] <- gg_dta[[\"trt\"]] <- gg_dta[[\"prior\"]] <- NULL plot(gg_dta, panel=TRUE)  gg_dta.cat[[\"karno\"]] <- gg_dta.cat[[\"diagtime\"]] <-     gg_dta.cat[[\"age\"]] <- NULL plot(gg_dta.cat, panel=TRUE, notch=TRUE)  gg_dta <- lapply(partial_veteran, gg_partial) gg_dta <- combine.gg_partial(gg_dta[[1]], gg_dta[[2]] )  plot(gg_dta[[\"karno\"]]) plot(gg_dta[[\"celltype\"]])  gg_dta.cat <- gg_dta gg_dta[[\"celltype\"]] <- gg_dta[[\"trt\"]] <- gg_dta[[\"prior\"]] <- NULL plot(gg_dta, panel=TRUE)  gg_dta.cat[[\"karno\"]] <- gg_dta.cat[[\"diagtime\"]] <-     gg_dta.cat[[\"age\"]] <- NULL plot(gg_dta.cat, panel=TRUE, notch=TRUE)  ## ------------------------------------------------------------ ## -------- pbc data # We need to create this dataset data(pbc, package = \"randomForestSRC\",)  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients  pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  varsel_pbc <- var.select(rfsrc_pbc)  xvar <- varsel_pbc$topvars  # Convert all partial plots to gg_partial objects gg_dta <- lapply(partial_pbc, gg_partial)  # Combine the objects to get multiple time curves # along variables on a single figure. pbc_ggpart <- combine.gg_partial(gg_dta[[1]], gg_dta[[2]],                                  lbls = c(\"1 Year\", \"3 Years\"))  summary(pbc_ggpart) class(pbc_ggpart[[\"bili\"]])  # Plot the highest ranked variable, by name. #plot(pbc_ggpart[[\"bili\"]])  # Create a temporary holder and remove the stage and edema data ggpart <- pbc_ggpart ggpart$edema <- NULL  # Panel plot the remainder. plot(ggpart, panel = TRUE)  plot(pbc_ggpart[[\"edema\"]]) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial_coplot.rfsrc.html","id":null,"dir":"Reference","previous_headings":"","what":"Data structures for stratified partial coplots — gg_partial_coplot.rfsrc","title":"Data structures for stratified partial coplots — gg_partial_coplot.rfsrc","text":"Data structures stratified partial coplots","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial_coplot.rfsrc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data structures for stratified partial coplots — gg_partial_coplot.rfsrc","text":"","code":"# S3 method for class 'rfsrc' gg_partial_coplot(   object,   xvar,   groups,   surv_type = c(\"mort\", \"rel.freq\", \"surv\", \"years.lost\", \"cif\", \"chf\"),   time,   show_plots = FALSE,   ... )"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial_coplot.rfsrc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data structures for stratified partial coplots — gg_partial_coplot.rfsrc","text":"object rfsrc object xvar list partial plot variables groups vector stratification variable. surv_type survival random forests,  c(\"mort\", \"rel.freq\", \"surv\", \"years.lost\", \"cif\", \"chf\") time vector time points survival random forests partial plots. show_plots boolean passed plot.variable show.plots argument. ... extra arguments passed plot.variable function","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial_coplot.rfsrc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data structures for stratified partial coplots — gg_partial_coplot.rfsrc","text":"gg_partial_coplot object. subclass gg_partial_list object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_partial_coplot.rfsrc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data structures for stratified partial coplots — gg_partial_coplot.rfsrc","text":"","code":"if (FALSE) { # \\dontrun{  ## ------------------------------------------------------------ ## -------- pbc data # We need to create this dataset data(pbc, package = \"randomForestSRC\")  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients  pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE ) # Create the variable plot. ggvar <- gg_variable(rfsrc_pbc, time = 1)  # Find intervals with similar number of observations. copper_cts <- quantile_pts(ggvar$copper, groups = 6, intervals = TRUE)  # Create the conditional groups and add to the gg_variable object copper_grp <- cut(ggvar$copper, breaks = copper_cts)  ## We would run this, but it's expensive partial_coplot_pbc <- gg_partial_coplot(rfsrc_pbc, xvar = \"bili\",                                          groups = copper_grp,                                          surv_type = \"surv\",                                          time = 1,                                          show.plots = FALSE)  # Partial coplot plot(partial_coplot_pbc) #, se = FALSE) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_rfsrc.rfsrc.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicted response data object — gg_rfsrc.rfsrc","title":"Predicted response data object — gg_rfsrc.rfsrc","text":"Extracts predicted response values rfsrc object, formats data plotting response using plot.gg_rfsrc.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_rfsrc.rfsrc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicted response data object — gg_rfsrc.rfsrc","text":"","code":"# S3 method for class 'rfsrc' gg_rfsrc(object, oob = TRUE, by, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_rfsrc.rfsrc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicted response data object — gg_rfsrc.rfsrc","text":"object rfsrc object oob boolean, return oob prediction , full forest prediction. stratifying variable training dataset, defaults NULL ... extra arguments","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_rfsrc.rfsrc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicted response data object — gg_rfsrc.rfsrc","text":"gg_rfsrc object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_rfsrc.rfsrc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predicted response data object — gg_rfsrc.rfsrc","text":"surv_type (\"surv\", \"chf\", \"mortality\", \"hazard\") survival    forests oob boolean, return oob prediction , full forest prediction.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_roc.rfsrc.html","id":null,"dir":"Reference","previous_headings":"","what":"ROC (Receiver operator curve) data from a classification random forest. — gg_roc.rfsrc","title":"ROC (Receiver operator curve) data from a classification random forest. — gg_roc.rfsrc","text":"sensitivity specificity randomForest classification object.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_roc.rfsrc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ROC (Receiver operator curve) data from a classification random forest. — gg_roc.rfsrc","text":"","code":"# S3 method for class 'rfsrc' gg_roc(object, which_outcome, oob, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_roc.rfsrc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ROC (Receiver operator curve) data from a classification random forest. — gg_roc.rfsrc","text":"object rfsrc classification object which_outcome select classification outcome interest. oob use oob estimates (default TRUE) ... extra arguments (used)","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_roc.rfsrc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ROC (Receiver operator curve) data from a classification random forest. — gg_roc.rfsrc","text":"gg_roc data.frame plotting ROC curves.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_roc.rfsrc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ROC (Receiver operator curve) data from a classification random forest. — gg_roc.rfsrc","text":"","code":"## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data rfsrc_iris <- rfsrc(Species ~ ., data = iris)  # ROC for setosa gg_dta <- gg_roc(rfsrc_iris, which_outcome=1) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 20 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   # ROC for versicolor gg_dta <- gg_roc(rfsrc_iris, which_outcome=2) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 48 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   # ROC for virginica gg_dta <- gg_roc(rfsrc_iris, which_outcome=3) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 39 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## -------- iris data rf_iris <- randomForest::randomForest(Species ~ ., data = iris)  # ROC for setosa gg_dta <- gg_roc(rf_iris, which_outcome=1) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 3 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   # ROC for versicolor gg_dta <- gg_roc(rf_iris, which_outcome=2) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 3 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   # ROC for virginica gg_dta <- gg_roc(rf_iris, which_outcome=3) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 3 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row."},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric survival estimates. — gg_survival","title":"Nonparametric survival estimates. — gg_survival","text":"Nonparametric survival estimates.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric survival estimates. — gg_survival","text":"","code":"gg_survival(   interval = NULL,   censor = NULL,   by = NULL,   data,   type = c(\"kaplan\", \"nelson\"),   ... )"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric survival estimates. — gg_survival","text":"interval name interval variable training dataset. censor name censoring variable training dataset. stratifying variable training dataset, defaults NULL data name training data.frame type one (\"kaplan\",\"nelson\"), defaults Kaplan-Meier ... extra arguments passed Kaplan Nelson functions.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric survival estimates. — gg_survival","text":"gg_survival object created using non-parametric Kaplan-Meier Nelson-Aalen estimators.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nonparametric survival estimates. — gg_survival","text":"gg_survival wrapper function generating nonparametric survival estimates using either nelson-Aalen kaplan-Meier estimates.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric survival estimates. — gg_survival","text":"","code":"if (FALSE) { # \\dontrun{ ## -------- pbc data data(pbc, package=\"randomForestSRC\") pbc$time <- pbc$days/364.25  # This is the same as kaplan gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc)  plot(gg_dta, error=\"none\") plot(gg_dta)  # Stratified on treatment variable. gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc, by=\"treatment\")  plot(gg_dta, error=\"none\") plot(gg_dta)  # ...with smaller confidence limits. gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc, by=\"treatment\", conf.int=.68)  plot(gg_dta, error=\"lines\") } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_variable.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal variable dependence data object. — gg_variable","title":"Marginal variable dependence data object. — gg_variable","text":"plot.variable generates data.frame containing marginal variable dependence partial variable dependence. gg_variable function creates data.frame containing full set covariate data (predictor variables) predicted response observation. Marginal dependence figures created using plot.gg_variable function. Optional arguments time point (vector points) interest (survival forests ) time_labels one time specified, vector time labels differentiating time points (survival forests ) oob indicate predicted results include oob full data set.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_variable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal variable dependence data object. — gg_variable","text":"","code":"gg_variable(object, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_variable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal variable dependence data object. — gg_variable","text":"object rfsrc object ... optional arguments","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_variable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marginal variable dependence data object. — gg_variable","text":"gg_variable object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_variable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Marginal variable dependence data object. — gg_variable","text":"marginal variable dependence determined comparing relation predicted response randomForest covariate interest. gg_variable function operates rfsrc object, output plot.variable function.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_variable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Marginal variable dependence data object. — gg_variable","text":"","code":"## ------------------------------------------------------------ ## classification ## ------------------------------------------------------------ ## -------- iris data ## iris rfsrc_iris <- rfsrc(Species ~., data = iris)  gg_dta <- gg_variable(rfsrc_iris) plot(gg_dta, xvar=\"Sepal.Width\") #> Warning: All aesthetics have length 1, but the data has 450 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.  plot(gg_dta, xvar=\"Sepal.Length\") #> Warning: All aesthetics have length 1, but the data has 450 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   plot(gg_dta, xvar=rfsrc_iris$xvar.names,      panel=TRUE) # , se=FALSE) #> Warning: All aesthetics have length 1, but the data has 1800 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## ------------------------------------------------------------ ## regression ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- air quality data rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality) gg_dta <- gg_variable(rfsrc_airq)  # an ordinal variable gg_dta[,\"Month\"] <- factor(gg_dta[,\"Month\"])  plot(gg_dta, xvar=\"Wind\") plot(gg_dta, xvar=\"Temp\") plot(gg_dta, xvar=\"Solar.R\")   plot(gg_dta, xvar=c(\"Solar.R\", \"Wind\", \"Temp\", \"Day\"), panel=TRUE)  plot(gg_dta, xvar=\"Month\", notch=TRUE) } # } if (FALSE) { # \\dontrun{ ## -------- motor trend cars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars)  gg_dta <- gg_variable(rfsrc_mtcars)  # mtcars$cyl is an ordinal variable gg_dta$cyl <- factor(gg_dta$cyl) gg_dta$am <- factor(gg_dta$am) gg_dta$vs <- factor(gg_dta$vs) gg_dta$gear <- factor(gg_dta$gear) gg_dta$carb <- factor(gg_dta$carb)  plot(gg_dta, xvar=\"cyl\")  # Others are continuous plot(gg_dta, xvar=\"disp\") plot(gg_dta, xvar=\"hp\") plot(gg_dta, xvar=\"wt\")  # panels plot(gg_dta,xvar=c(\"disp\",\"hp\", \"drat\", \"wt\", \"qsec\"),  panel=TRUE) plot(gg_dta, xvar=c(\"cyl\", \"vs\", \"am\", \"gear\", \"carb\"), panel=TRUE,      notch=TRUE) } # } ## -------- Boston data data(Boston, package=\"MASS\")  rf_boston <- randomForest::randomForest(medv~., data=Boston) gg_dta <- gg_variable(rf_boston) plot(gg_dta) #> [[1]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[2]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[3]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[4]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.  #>  #> [[5]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[6]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[7]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[8]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[9]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[10]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[11]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[12]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  #> [[13]] #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 506 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  #>  plot(gg_dta, panel = TRUE) #> Warning: Mismatched variable types... #>                   assuming these are all factor variables. #> Warning: All aesthetics have length 1, but the data has 6578 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> Warning: All aesthetics have length 1, but the data has 6578 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row. #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  ## ------------------------------------------------------------ ## survival examples ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- veteran data ## survival data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time,status)~., veteran, nsplit = 10,                         ntree = 100)                          # get the 1 year survival time. gg_dta <- gg_variable(rfsrc_veteran, time=90)  # Generate variable dependence plots for age and diagtime plot(gg_dta, xvar = \"age\") plot(gg_dta, xvar = \"diagtime\", )  # Generate coplots plot(gg_dta, xvar = c(\"age\", \"diagtime\"), panel=TRUE, se=FALSE)  # If we want to compare survival at different time points, say 30, 90 day # and 1 year gg_dta <- gg_variable(rfsrc_veteran, time=c(30, 90, 365))  # Generate variable dependence plots for age and diagtime plot(gg_dta, xvar = \"age\") } # } if (FALSE) { # \\dontrun{ ## -------- pbc data ## We don't run this because of bootstrap confidence limits # We need to create this dataset data(pbc, package = \"randomForestSRC\",)  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients  pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  gg_dta <- gg_variable(rfsrc_pbc, time=c(.5, 1, 3)) plot(gg_dta, xvar = \"age\") plot(gg_dta, xvar = \"trig\")  # Generate coplots plot(gg_dta, xvar = c(\"age\", \"trig\"), panel=TRUE, se=FALSE)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_vimp.html","id":null,"dir":"Reference","previous_headings":"","what":"Variable Importance (VIMP) data object — gg_vimp","title":"Variable Importance (VIMP) data object — gg_vimp","text":"gg_vimp Extracts variable importance (VIMP) information rfsrc object.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_vimp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variable Importance (VIMP) data object — gg_vimp","text":"","code":"gg_vimp(object, nvar, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_vimp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variable Importance (VIMP) data object — gg_vimp","text":"object rfsrc object output vimp nvar argument control number variables included output. ... arguments passed vimp.rfsrc function rfsrc object contain importance information.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_vimp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variable Importance (VIMP) data object — gg_vimp","text":"gg_vimp object. data.frame VIMP measures, rank order.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_vimp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Variable Importance (VIMP) data object — gg_vimp","text":"Ishwaran H. (2007). Variable importance binary regression trees forests, Electronic J. Statist., 1:519-537.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/gg_vimp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variable Importance (VIMP) data object — gg_vimp","text":"","code":"## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data rfsrc_iris <- rfsrc(Species ~ ., data = iris,                     importance = TRUE) gg_dta <- gg_vimp(rfsrc_iris) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 16 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## ------------------------------------------------------------ ## regression example ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- air quality data rfsrc_airq <- rfsrc(Ozone ~ ., airquality,                     importance = TRUE) gg_dta <- gg_vimp(rfsrc_airq) plot(gg_dta) } # }  ## -------- Boston data data(Boston, package=\"MASS\") rfsrc_boston <- randomForestSRC::rfsrc(medv~., Boston,                                        importance = TRUE) gg_dta <- gg_vimp(rfsrc_boston) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 13 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   ## -------- Boston data rf_boston <- randomForest::randomForest(medv~., Boston) gg_dta <- gg_vimp(rf_boston) plot(gg_dta) #> Warning: All aesthetics have length 1, but the data has 13 rows. #> ℹ Please consider using `annotate()` or provide this layer with data containing #>   a single row.   if (FALSE) { # \\dontrun{ ## -------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars,                       importance = TRUE) gg_dta <- gg_vimp(rfsrc_mtcars) plot(gg_dta) } # } ## ------------------------------------------------------------ ## survival example ## ------------------------------------------------------------ if (FALSE) { # \\dontrun{ ## -------- veteran data data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ .,     data = veteran,     ntree = 100,    importance = TRUE)  gg_dta <- gg_vimp(rfsrc_veteran) plot(gg_dta)  ## -------- pbc data # We need to create this dataset data(pbc, package = \"randomForestSRC\",)  # For whatever reason, the age variable is in days...  # makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  gg_dta <- gg_vimp(rfsrc_pbc) plot(gg_dta)  # Restrict to only the top 10. gg_dta <- gg_vimp(rfsrc_pbc, nvar=10) plot(gg_dta) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/kaplan.html","id":null,"dir":"Reference","previous_headings":"","what":"nonparametric Kaplan-Meier estimates — kaplan","title":"nonparametric Kaplan-Meier estimates — kaplan","text":"nonparametric Kaplan-Meier estimates","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/kaplan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"nonparametric Kaplan-Meier estimates — kaplan","text":"","code":"kaplan(interval, censor, data, by = NULL, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/kaplan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"nonparametric Kaplan-Meier estimates — kaplan","text":"interval name interval variable training dataset. censor name censoring variable training dataset. data name training set data.frame stratifying variable training dataset, defaults NULL ... arguments passed survfit function","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/kaplan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"nonparametric Kaplan-Meier estimates — kaplan","text":"gg_survival object","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/kaplan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"nonparametric Kaplan-Meier estimates — kaplan","text":"","code":"if (FALSE) { # \\dontrun{ # These get run through the gg_survival examples. data(pbc, package=\"randomForestSRC\") pbc$time <- pbc$days/364.25  # This is the same as gg_survival gg_dta <- kaplan(interval=\"time\", censor=\"status\",                      data=pbc)  plot(gg_dta, error=\"none\") plot(gg_dta)  # Stratified on treatment variable. gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc, by=\"treatment\")  plot(gg_dta, error=\"none\") plot(gg_dta) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/nelson.html","id":null,"dir":"Reference","previous_headings":"","what":"nonparametric Nelson-Aalen estimates — nelson","title":"nonparametric Nelson-Aalen estimates — nelson","text":"nonparametric Nelson-Aalen estimates","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/nelson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"nonparametric Nelson-Aalen estimates — nelson","text":"","code":"nelson(interval, censor, data, by = NULL, weight = NULL, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/nelson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"nonparametric Nelson-Aalen estimates — nelson","text":"interval name interval variable training dataset. censor name censoring variable training dataset. data name survival training data.frame stratifying variable training dataset, defaults NULL weight observation (default=NULL) ... arguments passed survfit function","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/nelson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"nonparametric Nelson-Aalen estimates — nelson","text":"gg_survival object","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/nelson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"nonparametric Nelson-Aalen estimates — nelson","text":"","code":"if (FALSE) { # \\dontrun{ # These get run through the gg_survival examples. data(pbc, package=\"randomForestSRC\") pbc$time <- pbc$days/364.25  # This is the same as gg_survival gg_dta <- nelson(interval=\"time\", censor=\"status\",                      data=pbc)  plot(gg_dta, error=\"none\") plot(gg_dta)  # Stratified on treatment variable. gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc, by=\"treatment\")  plot(gg_dta, error=\"none\") plot(gg_dta, error=\"lines\") plot(gg_dta)  gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc, by=\"treatment\",                      type=\"nelson\")  plot(gg_dta, error=\"bars\") plot(gg_dta)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a gg_error object — plot.gg_error","title":"Plot a gg_error object — plot.gg_error","text":"plot cumulative OOB error rates random forest function number trees.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a gg_error object — plot.gg_error","text":"","code":"# S3 method for class 'gg_error' plot(x, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a gg_error object — plot.gg_error","text":"x gg_error object created rfsrc object ... extra arguments passed ggplot functions","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a gg_error object — plot.gg_error","text":"ggplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_error.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a gg_error object — plot.gg_error","text":"gg_error plot used track convergence randomForest. figure reproduction error plot plot.rfsrc function.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_error.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot a gg_error object — plot.gg_error","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a gg_error object — plot.gg_error","text":"","code":"if (FALSE) { # \\dontrun{  ## Examples from RFSRC package... ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## ------------- iris data ## You can build a randomForest rfsrc_iris <- rfsrc(Species ~ ., data = iris, tree.err = TRUE)  # Get a data.frame containing error rates gg_dta <- gg_error(rfsrc_iris)  # Plot the gg_error object plot(gg_dta)  ## RandomForest example rf_iris <- randomForest::randomForest(Species ~ ., data = iris,                                       tree.err = TRUE, ) gg_dta <- gg_error(rf_iris) plot(gg_dta)  gg_dta <- gg_error(rf_iris, training=TRUE) plot(gg_dta) ## ------------------------------------------------------------ ## Regression example ## ------------------------------------------------------------ ## ------------- airq data rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality,     na.action = \"na.impute\", tree.err = TRUE, )  # Get a data.frame containing error rates gg_dta <- gg_error(rfsrc_airq)  # Plot the gg_error object plot(gg_dta)   ## ------------- Boston data data(Boston, package = \"MASS\") Boston$chas <- as.logical(Boston$chas) rfsrc_boston <- rfsrc(medv ~ .,    data = Boston,    forest = TRUE,    importance = TRUE,    tree.err = TRUE,    save.memory = TRUE)  # Get a data.frame containing error rates gg_dta<- gg_error(rfsrc_boston)  # Plot the gg_error object plot(gg_dta)  ## ------------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars, tree.err = TRUE) # Get a data.frame containing error rates gg_dta<- gg_error(rfsrc_mtcars)  # Plot the gg_error object plot(gg_dta)   ## ------------------------------------------------------------ ## Survival example ## ------------------------------------------------------------ ## ------------- veteran data ## randomized trial of two treatment regimens for lung cancer data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ ., data = veteran,                        tree.err = TRUE)  gg_dta <- gg_error(rfsrc_veteran) plot(gg_dta)  ## ------------- pbc data # Load a cached randomForestSRC object # We need to create this dataset data(pbc, package = \"randomForestSRC\",) # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  tree.err = TRUE,  forest = TRUE,  importance = TRUE,  save.memory = TRUE )   gg_dta <- gg_error(rfsrc_pbc) plot(gg_dta)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_interaction.html","id":null,"dir":"Reference","previous_headings":"","what":"plot.gg_interaction Plot a gg_interaction object, — plot.gg_interaction","title":"plot.gg_interaction Plot a gg_interaction object, — plot.gg_interaction","text":"plot.gg_interaction Plot gg_interaction object,","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_interaction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot.gg_interaction Plot a gg_interaction object, — plot.gg_interaction","text":"","code":"# S3 method for class 'gg_interaction' plot(x, xvar, lbls, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_interaction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot.gg_interaction Plot a gg_interaction object, — plot.gg_interaction","text":"x gg_interaction object created rfsrc object xvar variable (list variables) interest. lbls vector alternative variable names. ... arguments passed gg_interaction function.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_interaction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot.gg_interaction Plot a gg_interaction object, — plot.gg_interaction","text":"ggplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_interaction.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"plot.gg_interaction Plot a gg_interaction object, — plot.gg_interaction","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_interaction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot.gg_interaction Plot a gg_interaction object, — plot.gg_interaction","text":"","code":"if (FALSE) { # \\dontrun{ ## Examples from randomForestSRC package... ## ------------------------------------------------------------ ## find interactions, classification setting ## ------------------------------------------------------------ ## -------- iris data ## iris.obj <- rfsrc(Species ~., data = iris) ## TODO: VIMP interactions not handled yet.... ## find.interaction(iris.obj, method = \"vimp\", nrep = 3) ## interaction_iris <- find.interaction(iris.obj) data(interaction_iris, package=\"ggRandomForests\") gg_dta <- gg_interaction(interaction_iris)  plot(gg_dta, xvar=\"Petal.Width\") plot(gg_dta, xvar=\"Petal.Length\") plot(gg_dta, panel=TRUE)  ## ------------------------------------------------------------ ## find interactions, regression setting ## ------------------------------------------------------------ ## -------- air quality data ## airq.obj <- rfsrc(Ozone ~ ., data = airquality) ## ## TODO: VIMP interactions not handled yet.... ## find.interaction(airq.obj, method = \"vimp\", nrep = 3) ## interaction_airq <- find.interaction(airq.obj) data(interaction_airq, package=\"ggRandomForests\") gg_dta <- gg_interaction(interaction_airq)  plot(gg_dta, xvar=\"Temp\") plot(gg_dta, xvar=\"Solar.R\") plot(gg_dta, panel=TRUE)  ## -------- Boston data data(interaction_boston, package=\"ggRandomForests\") gg_dta <- gg_interaction(interaction_boston)  plot(gg_dta, panel=TRUE)  ## -------- mtcars data data(interaction_mtcars, package=\"ggRandomForests\") gg_dta <- gg_interaction(interaction_mtcars)  plot(gg_dta, panel=TRUE)  ## ------------------------------------------------------------ ## find interactions, survival setting ## ------------------------------------------------------------ ## -------- pbc data ## data(pbc, package = \"randomForestSRC\") ## pbc.obj <- rfsrc(Surv(days,status) ~ ., pbc, nsplit = 10) ## interaction_pbc <- find.interaction(pbc.obj, nvar = 8) data(interaction_pbc, package=\"ggRandomForests\") gg_dta <- gg_interaction(interaction_pbc)  plot(gg_dta, xvar=\"bili\") plot(gg_dta, xvar=\"copper\") plot(gg_dta, panel=TRUE)  ## -------- veteran data data(interaction_veteran, package=\"ggRandomForests\") gg_dta <- gg_interaction(interaction_veteran)  plot(gg_dta, panel=TRUE)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a gg_minimal_depth object for random forest variable ranking. — plot.gg_minimal_depth","title":"Plot a gg_minimal_depth object for random forest variable ranking. — plot.gg_minimal_depth","text":"Plot gg_minimal_depth object random forest variable ranking.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a gg_minimal_depth object for random forest variable ranking. — plot.gg_minimal_depth","text":"","code":"# S3 method for class 'gg_minimal_depth' plot(x, selection = FALSE, type = c(\"named\", \"rank\"), lbls, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a gg_minimal_depth object for random forest variable ranking. — plot.gg_minimal_depth","text":"x gg_minimal_depth object created rfsrc object selection restrict plot include variables selected minimal depth criteria (boolean). type select type y axis labels c(\"named\",\"rank\") lbls vector alternative variable names. ... optional arguments passed gg_minimal_depth","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_depth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a gg_minimal_depth object for random forest variable ranking. — plot.gg_minimal_depth","text":"ggplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_depth.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot a gg_minimal_depth object for random forest variable ranking. — plot.gg_minimal_depth","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2014). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.5.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a gg_minimal_depth object for random forest variable ranking. — plot.gg_minimal_depth","text":"","code":"if (FALSE) { # \\dontrun{ ## Examples from RFSRC package... ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data ## You can build a randomForest rfsrc_iris <- rfsrc(Species ~ ., data = iris) varsel_iris <- var.select(rfsrc_iris)  # Get a data.frame containing minimaldepth measures gg_dta<- gg_minimal_depth(varsel_iris)  # Plot the gg_minimal_depth object plot(gg_dta)  ## ------------------------------------------------------------ ## Regression example ## ------------------------------------------------------------ ## -------- air quality data rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality, na.action = \"na.impute\") varsel_airq <- var.select(rfsrc_airq)  # Get a data.frame containing error rates gg_dta<- gg_minimal_depth(varsel_airq)  # Plot the gg_minimal_depth object plot(gg_dta)  ## -------- Boston data data(Boston, package=\"MASS\") rfsrc_boston <- randomForestSRC::rfsrc(medv~., Boston) # Get a data.frame containing error rates plot(gg_minimal_depth(varsel_boston))  ## -------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars) varsel_mtcars <- var.select(rfsrc_mtcars)   # Get a data.frame containing error rates plot.gg_minimal_depth(varsel_mtcars)  ## ------------------------------------------------------------ ## Survival example ## ------------------------------------------------------------ ## -------- veteran data ## randomized trial of two treatment regimens for lung cancer data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ ., data = veteran, ntree = 100) varsel_veteran <- var.select(rfsrc_veteran)  gg_dta <- gg_minimal_depth(varsel_veteran) plot(gg_dta)  ## -------- pbc data #' # We need to create this dataset data(pbc, package = \"randomForestSRC\",) # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  varsel_pbc <- var.select(rfsrc_pbc)  gg_dta <- gg_minimal_depth(varsel_pbc) plot(gg_dta)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_vimp.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a gg_minimal_vimp object for comparing the Minimal Depth and VIMP variable rankings. — plot.gg_minimal_vimp","title":"Plot a gg_minimal_vimp object for comparing the Minimal Depth and VIMP variable rankings. — plot.gg_minimal_vimp","text":"Plot gg_minimal_vimp object comparing Minimal Depth VIMP variable rankings.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_vimp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a gg_minimal_vimp object for comparing the Minimal Depth and VIMP variable rankings. — plot.gg_minimal_vimp","text":"","code":"# S3 method for class 'gg_minimal_vimp' plot(x, nvar, lbls, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_vimp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a gg_minimal_vimp object for comparing the Minimal Depth and VIMP variable rankings. — plot.gg_minimal_vimp","text":"x gg_minimal_depth object created var.select object nvar figure restricted subset points. lbls vector alternative variable names. ... optional arguments (used)","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_vimp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a gg_minimal_vimp object for comparing the Minimal Depth and VIMP variable rankings. — plot.gg_minimal_vimp","text":"ggplot object","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_minimal_vimp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a gg_minimal_vimp object for comparing the Minimal Depth and VIMP variable rankings. — plot.gg_minimal_vimp","text":"","code":"if (FALSE) { # \\dontrun{ ## Examples from RFSRC package... ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data ## You can build a randomForest rfsrc_iris <- rfsrc(Species ~ ., data = iris) varsel_iris <- var.select(rfsrc_iris)  # Get a data.frame containing minimaldepth measures gg_dta<- gg_minimal_vimp(varsel_iris)  # Plot the gg_minimal_depth object plot(gg_dta)  ## ------------------------------------------------------------ ## Regression example ## ------------------------------------------------------------ ## -------- air quality data rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality, na.action = \"na.impute\") varsel_airq <- var.select(rfsrc_airq)  # Get a data.frame containing error rates gg_dta<- gg_minimal_vimp(varsel_airq)  # Plot the gg_minimal_vimp object plot(gg_dta)  ## -------- Boston data data(Boston, package=\"MASS\") rfsrc_boston <- randomForestSRC::rfsrc(medv~., Boston)  varsel_boston <- var.select(rfsrc_boston)  # Get a data.frame containing error rates gg_dta<- gg_minimal_vimp(varsel_boston)  # Plot the gg_minimal_vimp object plot(gg_dta)  ## -------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars) varsel_mtcars <- var.select(rfsrc_mtcars)  # Get a data.frame containing error rates gg_dta<- gg_minimal_vimp(varsel_mtcars)  # Plot the gg_minimal_vimp object plot(gg_dta)  ## ------------------------------------------------------------ ## Survival example ## ------------------------------------------------------------ ## -------- veteran data ## randomized trial of two treatment regimens for lung cancer data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ ., data = veteran, ntree = 100) varsel_veteran <- var.select(rfsrc_veteran)  gg_dta <- gg_minimal_vimp(varsel_veteran) plot(gg_dta)  ## -------- pbc data # We need to create this dataset data(pbc, package = \"randomForestSRC\",) # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  varsel_pbc <- var.select(rfsrc_pbc)  gg_dta <- gg_minimal_vimp(varsel_pbc) plot(gg_dta) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial.html","id":null,"dir":"Reference","previous_headings":"","what":"Partial variable dependence plot, operates on a gg_partial object. — plot.gg_partial","title":"Partial variable dependence plot, operates on a gg_partial object. — plot.gg_partial","text":"Generate risk adjusted (partial) variable dependence plot. function plots rfsrc response variable (y-axis) covariate interest (specified creating  gg_partial object).","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partial variable dependence plot, operates on a gg_partial object. — plot.gg_partial","text":"","code":"# S3 method for class 'gg_partial' plot(x, points = TRUE, error = c(\"none\", \"shade\", \"bars\", \"lines\"), ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partial variable dependence plot, operates on a gg_partial object. — plot.gg_partial","text":"x gg_partial object created rfsrc forest object points plot points (boolean) smooth line. error \"shade\", \"bars\", \"lines\" \"none\" ... extra arguments passed ggplot2 functions.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partial variable dependence plot, operates on a gg_partial object. — plot.gg_partial","text":"ggplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Partial variable dependence plot, operates on a gg_partial object. — plot.gg_partial","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partial variable dependence plot, operates on a gg_partial object. — plot.gg_partial","text":"","code":"if (FALSE) { # \\dontrun{ ## ------------------------------------------------------------ ## classification ## ------------------------------------------------------------ ## -------- iris data  ## iris \"Petal.Width\" partial dependence plot ## # rfsrc_iris <- rfsrc(Species ~., data = iris) # partial_iris <- plot.variable(rfsrc_iris, xvar.names = \"Petal.Width\", #                            partial=TRUE) data(partial_iris, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_iris) plot(gg_dta)  ## ------------------------------------------------------------ ## regression ## ------------------------------------------------------------ ## -------- air quality data ## airquality \"Wind\" partial dependence plot ## # rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality) # partial_airq <- plot.variable(rfsrc_airq, xvar.names = \"Wind\", #                            partial=TRUE, show.plot=FALSE) data(partial_airq, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_airq) plot(gg_dta)  gg_dta.m <- gg_dta[[\"Month\"]] plot(gg_dta.m, notch=TRUE)  gg_dta[[\"Month\"]] <- NULL plot(gg_dta, panel=TRUE)  ## -------- Boston data data(partial_boston, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_boston) plot(gg_dta) plot(gg_dta, panel=TRUE)  ## -------- mtcars data data(partial_mtcars, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_mtcars)  plot(gg_dta)  gg_dta.cat <- gg_dta gg_dta.cat[[\"disp\"]] <- gg_dta.cat[[\"wt\"]] <- gg_dta.cat[[\"hp\"]] <- NULL gg_dta.cat[[\"drat\"]] <- gg_dta.cat[[\"carb\"]] <-    gg_dta.cat[[\"qsec\"]] <- NULL  plot(gg_dta.cat, panel=TRUE)  gg_dta[[\"cyl\"]] <- gg_dta[[\"vs\"]] <- gg_dta[[\"am\"]] <- NULL gg_dta[[\"gear\"]] <- NULL plot(gg_dta, panel=TRUE)  ## ------------------------------------------------------------ ## survival examples ## ------------------------------------------------------------ ## -------- veteran data ## survival \"age\" partial variable dependence plot ## # data(veteran, package = \"randomForestSRC\") # rfsrc_veteran <- rfsrc(Surv(time,status)~., veteran, nsplit = 10, #                        ntree = 100) # ## 30 day partial plot for age # partial_veteran <- plot.variable(rfsrc_veteran, surv.type = \"surv\", #                               partial = TRUE, time=30, #                               xvar.names = \"age\", #                               show.plots=FALSE) data(partial_veteran, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_veteran[[1]]) plot(gg_dta)  gg_dta.cat <- gg_dta gg_dta[[\"celltype\"]] <- gg_dta[[\"trt\"]] <- gg_dta[[\"prior\"]] <- NULL plot(gg_dta, panel=TRUE)  gg_dta.cat[[\"karno\"]] <- gg_dta.cat[[\"diagtime\"]] <-      gg_dta.cat[[\"age\"]] <- NULL plot(gg_dta.cat, panel=TRUE, notch=TRUE)  gg_dta <- lapply(partial_veteran, gg_partial) length(gg_dta) gg_dta <- combine.gg_partial(gg_dta[[1]], gg_dta[[2]] )  plot(gg_dta[[\"karno\"]]) plot(gg_dta[[\"celltype\"]])  gg_dta.cat <- gg_dta gg_dta[[\"celltype\"]] <- gg_dta[[\"trt\"]] <- gg_dta[[\"prior\"]] <- NULL plot(gg_dta, panel=TRUE)  gg_dta.cat[[\"karno\"]] <- gg_dta.cat[[\"diagtime\"]] <-      gg_dta.cat[[\"age\"]] <- NULL plot(gg_dta.cat, panel=TRUE, notch=TRUE)  ## -------- pbc data } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Partial variable dependence plot, operates on a gg_partial_list object. — plot.gg_partial_list","title":"Partial variable dependence plot, operates on a gg_partial_list object. — plot.gg_partial_list","text":"Generate risk adjusted (partial) variable dependence plot. function plots rfsrc response variable (y-axis) covariate interest (specified creating gg_partial_list object).","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partial variable dependence plot, operates on a gg_partial_list object. — plot.gg_partial_list","text":"","code":"# S3 method for class 'gg_partial_list' plot(x, points = TRUE, panel = FALSE, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partial variable dependence plot, operates on a gg_partial_list object. — plot.gg_partial_list","text":"x gg_partial_list object created gg_partial forest object points plot points (boolean) smooth line. panel entire list plotted together? ... extra arguments","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partial variable dependence plot, operates on a gg_partial_list object. — plot.gg_partial_list","text":"list ggplot objects, single faceted ggplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial_list.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Partial variable dependence plot, operates on a gg_partial_list object. — plot.gg_partial_list","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_partial_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partial variable dependence plot, operates on a gg_partial_list object. — plot.gg_partial_list","text":"","code":"if (FALSE) { # \\dontrun{ ## ------------------------------------------------------------ ## classification ## ------------------------------------------------------------ ## -------- iris data  ## iris \"Petal.Width\" partial dependence plot ## # rfsrc_iris <- rfsrc(Species ~., data = iris) # partial_iris <- plot.variable(rfsrc_iris, xvar.names = \"Petal.Width\", #                            partial=TRUE) data(partial_iris, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_iris) plot(gg_dta)  ## ------------------------------------------------------------ ## regression ## ------------------------------------------------------------ ## -------- air quality data ## airquality \"Wind\" partial dependence plot ## # rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality) # partial_airq <- plot.variable(rfsrc_airq, xvar.names = \"Wind\", #                            partial=TRUE, show.plot=FALSE) data(partial_airq, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_airq) plot(gg_dta)  gg_dta.m <- gg_dta[[\"Month\"]] plot(gg_dta.m, notch=TRUE)  gg_dta[[\"Month\"]] <- NULL plot(gg_dta, panel=TRUE)  ## -------- Boston data data(partial_boston, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_boston) plot(gg_dta) plot(gg_dta, panel=TRUE)  ## -------- mtcars data data(partial_mtcars, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_mtcars)  plot(gg_dta)  gg_dta.cat <- gg_dta gg_dta.cat[[\"disp\"]] <- gg_dta.cat[[\"wt\"]] <- gg_dta.cat[[\"hp\"]] <- NULL gg_dta.cat[[\"drat\"]] <- gg_dta.cat[[\"carb\"]] <- gg_dta.cat[[\"qsec\"]] <- NULL  plot(gg_dta.cat, panel=TRUE)  gg_dta[[\"cyl\"]] <- gg_dta[[\"vs\"]] <- gg_dta[[\"am\"]] <- NULL gg_dta[[\"gear\"]] <- NULL plot(gg_dta, panel=TRUE)  ## ------------------------------------------------------------ ## survival examples ## ------------------------------------------------------------ ## -------- veteran data ## survival \"age\" partial variable dependence plot ## # data(veteran, package = \"randomForestSRC\") # rfsrc_veteran <- rfsrc(Surv(time,status)~., veteran, nsplit = 10, #                        ntree = 100) # ## 30 day partial plot for age # partial_veteran <- plot.variable(rfsrc_veteran, surv.type = \"surv\", #                               partial = TRUE, time=30, #                               xvar.names = \"age\", #                               show.plots=FALSE) data(partial_veteran, package=\"ggRandomForests\")  gg_dta <- gg_partial(partial_veteran[[1]]) plot(gg_dta)  gg_dta.cat <- gg_dta gg_dta[[\"celltype\"]] <- gg_dta[[\"trt\"]] <- gg_dta[[\"prior\"]] <- NULL plot(gg_dta, panel=TRUE)  gg_dta.cat[[\"karno\"]] <- gg_dta.cat[[\"diagtime\"]] <-     gg_dta.cat[[\"age\"]] <- NULL plot(gg_dta.cat, panel=TRUE, notch=TRUE)  gg_dta <- lapply(partial_veteran, gg_partial) length(gg_dta) gg_dta <- combine.gg_partial(gg_dta[[1]], gg_dta[[2]] )  plot(gg_dta[[\"karno\"]]) plot(gg_dta[[\"celltype\"]])  gg_dta.cat <- gg_dta gg_dta[[\"celltype\"]] <- gg_dta[[\"trt\"]] <- gg_dta[[\"prior\"]] <- NULL plot(gg_dta, panel=TRUE)  gg_dta.cat[[\"karno\"]] <- gg_dta.cat[[\"diagtime\"]] <-      gg_dta.cat[[\"age\"]] <- NULL plot(gg_dta.cat, panel=TRUE, notch=TRUE)  ## -------- pbc data } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_rfsrc.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicted response plot from a gg_rfsrc object. — plot.gg_rfsrc","title":"Predicted response plot from a gg_rfsrc object. — plot.gg_rfsrc","text":"Plot predicted response gg_rfsrc object, rfsrc prediction, using OOB prediction forest.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_rfsrc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicted response plot from a gg_rfsrc object. — plot.gg_rfsrc","text":"","code":"# S3 method for class 'gg_rfsrc' plot(x, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_rfsrc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicted response plot from a gg_rfsrc object. — plot.gg_rfsrc","text":"x gg_rfsrc object created rfsrc object ... arguments passed gg_rfsrc.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_rfsrc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicted response plot from a gg_rfsrc object. — plot.gg_rfsrc","text":"ggplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_rfsrc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predicted response plot from a gg_rfsrc object. — plot.gg_rfsrc","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_rfsrc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predicted response plot from a gg_rfsrc object. — plot.gg_rfsrc","text":"","code":"if (FALSE) { # \\dontrun{ ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data # rfsrc_iris <- rfsrc(Species ~ ., data = iris) data(rfsrc_iris, package=\"ggRandomForests\") gg_dta<- gg_rfsrc(rfsrc_iris)  plot(gg_dta)  ## ------------------------------------------------------------ ## Regression example ## ------------------------------------------------------------ ## -------- air quality data rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality, na.action = \"na.impute\") gg_dta<- gg_rfsrc(rfsrc_airq)  plot(gg_dta)  ## -------- Boston data data(Boston, package = \"MASS\") rfsrc_boston <- randomForestSRC::rfsrc(medv~., Boston)  plot(rfsrc_boston)  ## -------- mtcars data rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars) gg_dta<- gg_rfsrc(rfsrc_mtcars)  plot(gg_dta)  ## ------------------------------------------------------------ ## Survival example ## ------------------------------------------------------------ ## -------- veteran data ## randomized trial of two treatment regimens for lung cancer data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time, status) ~ ., data = veteran, ntree = 100) gg_dta <- gg_rfsrc(rfsrc_veteran) plot(gg_dta)  gg_dta <- gg_rfsrc(rfsrc_veteran, conf.int=.95) plot(gg_dta)  gg_dta <- gg_rfsrc(rfsrc_veteran, by=\"trt\") plot(gg_dta)  ## -------- pbc data #' # We need to create this dataset data(pbc, package = \"randomForestSRC\",)  # For whatever reason, the age variable is in days... makes no sense to me for (ind in seq_len(dim(pbc)[2])) {  if (!is.factor(pbc[, ind])) {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(range(pbc[, ind], na.rm = TRUE) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  } else {    if (length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 2) {      if (sum(sort(unique(pbc[, ind])) == c(0, 1)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }      if (sum(sort(unique(pbc[, ind])) == c(FALSE, TRUE)) == 2) {        pbc[, ind] <- as.logical(pbc[, ind])      }    }  }  if (!is.logical(pbc[, ind]) &      length(unique(pbc[which(!is.na(pbc[, ind])), ind])) <= 5) {    pbc[, ind] <- factor(pbc[, ind])  } } #Convert age to years pbc$age <- pbc$age / 364.24  pbc$years <- pbc$days / 364.24 pbc <- pbc[, -which(colnames(pbc) == \"days\")] pbc$treatment <- as.numeric(pbc$treatment) pbc$treatment[which(pbc$treatment == 1)] <- \"DPCA\" pbc$treatment[which(pbc$treatment == 2)] <- \"placebo\" pbc$treatment <- factor(pbc$treatment) dta_train <- pbc[-which(is.na(pbc$treatment)), ] # Create a test set from the remaining patients pbc_test <- pbc[which(is.na(pbc$treatment)), ]  #======== # build the forest: rfsrc_pbc <- randomForestSRC::rfsrc(   Surv(years, status) ~ .,  dta_train,  nsplit = 10,  na.action = \"na.impute\",  forest = TRUE,  importance = TRUE,  save.memory = TRUE )  gg_dta <- gg_rfsrc(rfsrc_pbc) plot(gg_dta)  gg_dta <- gg_rfsrc(rfsrc_pbc, conf.int=.95) plot(gg_dta)  gg_dta <- gg_rfsrc(rfsrc_pbc, by=\"treatment\") plot(gg_dta)   } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_roc.html","id":null,"dir":"Reference","previous_headings":"","what":"ROC plot generic function for a gg_roc object. — plot.gg_roc","title":"ROC plot generic function for a gg_roc object. — plot.gg_roc","text":"ROC plot generic function gg_roc object.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_roc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ROC plot generic function for a gg_roc object. — plot.gg_roc","text":"","code":"# S3 method for class 'gg_roc' plot(x, which_outcome = NULL, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_roc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ROC plot generic function for a gg_roc object. — plot.gg_roc","text":"x gg_roc object created classification forest which_outcome multiclass problems, choose class plotting ... arguments passed gg_roc function","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_roc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ROC plot generic function for a gg_roc object. — plot.gg_roc","text":"ggplot object ROC curve","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_roc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"ROC plot generic function for a gg_roc object. — plot.gg_roc","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_roc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ROC plot generic function for a gg_roc object. — plot.gg_roc","text":"","code":"if (FALSE) { # \\dontrun{ ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data #rfsrc_iris <- rfsrc(Species ~ ., data = iris) data(rfsrc_iris, package=\"ggRandomForests\")  # ROC for setosa gg_dta <- gg_roc(rfsrc_iris, which_outcome=1) plot.gg_roc(gg_dta)  # ROC for versicolor gg_dta <- gg_roc(rfsrc_iris, which_outcome=2) plot.gg_roc(gg_dta)  # ROC for virginica gg_dta <- gg_roc(rfsrc_iris, which_outcome=3) plot.gg_roc(gg_dta)  # Alternatively, you can plot all three outcomes in one go # by calling the plot function on the forest object. plot.gg_roc(rfsrc_iris)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a gg_survival object. — plot.gg_survival","title":"Plot a gg_survival object. — plot.gg_survival","text":"Plot gg_survival  object.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a gg_survival object. — plot.gg_survival","text":"","code":"# S3 method for class 'gg_survival' plot(   x,   type = c(\"surv\", \"cum_haz\", \"hazard\", \"density\", \"mid_int\", \"life\", \"proplife\"),   error = c(\"shade\", \"bars\", \"lines\", \"none\"),   label = NULL,   ... )"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a gg_survival object. — plot.gg_survival","text":"x gg_survival survival gg_rfsrc object created rfsrc object type \"surv\", \"cum_haz\", \"hazard\", \"density\", \"mid_int\", \"life\", \"proplife\" error \"shade\", \"bars\", \"lines\" \"none\" label Modify legend label gg_survival stratified samples ... used","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a gg_survival object. — plot.gg_survival","text":"ggplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a gg_survival object. — plot.gg_survival","text":"","code":"if (FALSE) { # \\dontrun{ ## -------- pbc data data(pbc, package=\"randomForestSRC\") pbc$time <- pbc$days/364.25  # This is the same as kaplan gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc)  plot(gg_dta, error=\"none\") plot(gg_dta)  # Stratified on treatment variable. gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc, by=\"treatment\")  plot(gg_dta, error=\"none\") plot(gg_dta) plot(gg_dta, label=\"treatment\")  # ...with smaller confidence limits. gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc, by=\"treatment\", conf.int=.68)  plot(gg_dta, error=\"lines\") plot(gg_dta, label=\"treatment\", error=\"lines\")  # ...with smaller confidence limits. gg_dta <- gg_survival(interval=\"time\", censor=\"status\",                      data=pbc, by=\"sex\", conf.int=.68)  plot(gg_dta, error=\"lines\") plot(gg_dta, label=\"sex\", error=\"lines\")   } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_variable.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a gg_variable object, — plot.gg_variable","title":"Plot a gg_variable object, — plot.gg_variable","text":"Plot gg_variable object,","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_variable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a gg_variable object, — plot.gg_variable","text":"","code":"# S3 method for class 'gg_variable' plot(   x,   xvar,   time,   time_labels,   panel = FALSE,   oob = TRUE,   points = TRUE,   smooth = TRUE,   ... )"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_variable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a gg_variable object, — plot.gg_variable","text":"x gg_variable object created rfsrc object xvar variable (list variables) interest. time survival, one times interest time_labels string labels times panel plots faceted along multiple xvar? oob oob estimates (boolean) points plot raw data points (boolean) smooth include smooth curve (boolean) ... arguments passed ggplot2 functions.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_variable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a gg_variable object, — plot.gg_variable","text":"single ggplot object, list ggplot objects","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_variable.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot a gg_variable object, — plot.gg_variable","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_variable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a gg_variable object, — plot.gg_variable","text":"","code":"if (FALSE) { # \\dontrun{ ## ------------------------------------------------------------ ## classification ## ------------------------------------------------------------ ## -------- iris data ## iris #rfsrc_iris <- rfsrc(Species ~., data = iris) data(rfsrc_iris, package=\"ggRandomForests\")  gg_dta <- gg_variable(rfsrc_iris) plot(gg_dta, xvar=\"Sepal.Width\") plot(gg_dta, xvar=\"Sepal.Length\")  ## !! TODO !! this needs to be corrected plot(gg_dta, xvar=rfsrc_iris$xvar.names,      panel=TRUE, se=FALSE)  ## ------------------------------------------------------------ ## regression ## ------------------------------------------------------------ ## -------- air quality data #rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality) data(rfsrc_airq, package=\"ggRandomForests\") gg_dta <- gg_variable(rfsrc_airq)  # an ordinal variable gg_dta[,\"Month\"] <- factor(gg_dta[,\"Month\"])  plot(gg_dta, xvar=\"Wind\") plot(gg_dta, xvar=\"Temp\") plot(gg_dta, xvar=\"Solar.R\")  plot(gg_dta, xvar=c(\"Solar.R\", \"Wind\", \"Temp\", \"Day\"), panel=TRUE)  plot(gg_dta, xvar=\"Month\", notch=TRUE)  ## -------- motor trend cars data #rfsrc_mtcars <- rfsrc(mpg ~ ., data = mtcars) data(rfsrc_mtcars, package=\"ggRandomForests\") gg_dta <- gg_variable(rfsrc_mtcars)  # mtcars$cyl is an ordinal variable gg_dta$cyl <- factor(gg_dta$cyl) gg_dta$am <- factor(gg_dta$am) gg_dta$vs <- factor(gg_dta$vs) gg_dta$gear <- factor(gg_dta$gear) gg_dta$carb <- factor(gg_dta$carb)  plot(gg_dta, xvar=\"cyl\")  # Others are continuous plot(gg_dta, xvar=\"disp\") plot(gg_dta, xvar=\"hp\") plot(gg_dta, xvar=\"wt\")  # panel plot(gg_dta,xvar=c(\"disp\",\"hp\", \"drat\", \"wt\", \"qsec\"),  panel=TRUE) plot(gg_dta, xvar=c(\"cyl\", \"vs\", \"am\", \"gear\", \"carb\") ,panel=TRUE)  ## -------- Boston data  ## ------------------------------------------------------------ ## survival examples ## ------------------------------------------------------------ ## -------- veteran data ## survival data(veteran, package = \"randomForestSRC\") rfsrc_veteran <- rfsrc(Surv(time,status)~., veteran, nsplit = 10,                        ntree = 100)  # get the 1 year survival time. gg_dta <- gg_variable(rfsrc_veteran, time=90)  # Generate variable dependance plots for age and diagtime plot(gg_dta, xvar = \"age\") plot(gg_dta, xvar = \"diagtime\")  # Generate coplots plot(gg_dta, xvar = c(\"age\", \"diagtime\"), panel=TRUE)  # If we want to compare survival at different time points, say 30, 90 day # and 1 year gg_dta <- gg_variable(rfsrc_veteran, time=c(30, 90, 365))  # Generate variable dependance plots for age and diagtime plot(gg_dta, xvar = \"age\") plot(gg_dta, xvar = \"diagtime\")  # Generate coplots plot(gg_dta, xvar =  c(\"age\", \"diagtime\"), panel=TRUE)  ## -------- pbc data } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_vimp.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a gg_vimp object, extracted variable importance of a rfsrc object — plot.gg_vimp","title":"Plot a gg_vimp object, extracted variable importance of a rfsrc object — plot.gg_vimp","text":"Plot gg_vimp object, extracted variable importance rfsrc object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_vimp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a gg_vimp object, extracted variable importance of a rfsrc object — plot.gg_vimp","text":"","code":"# S3 method for class 'gg_vimp' plot(x, relative, lbls, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_vimp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a gg_vimp object, extracted variable importance of a rfsrc object — plot.gg_vimp","text":"x gg_vimp object created rfsrc object relative plot vimp relative vimp. Defaults vimp. lbls vector alternative variable labels. Item names variable names. ... optional arguments passed gg_vimp necessary","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_vimp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a gg_vimp object, extracted variable importance of a rfsrc object — plot.gg_vimp","text":"ggplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_vimp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot a gg_vimp object, extracted variable importance of a rfsrc object — plot.gg_vimp","text":"Breiman L. (2001). Random forests, Machine Learning, 45:5-32. Ishwaran H. Kogalur U.B. (2007). Random survival forests R, Rnews, 7(2):25-31. Ishwaran H. Kogalur U.B. (2013). Random Forests Survival, Regression Classification (RF-SRC), R package version 1.4.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/plot.gg_vimp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a gg_vimp object, extracted variable importance of a rfsrc object — plot.gg_vimp","text":"","code":"if (FALSE) { # \\dontrun{ ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## -------- iris data # rfsrc_iris <- rfsrc(Species ~ ., data = iris) data(rfsrc_iris, package=\"ggRandomForests\") gg_dta <- gg_vimp(rfsrc_iris) plot(gg_dta)  ## ------------------------------------------------------------ ## regression example ## ------------------------------------------------------------ ## -------- air quality data # rfsrc_airq <- rfsrc(Ozone ~ ., airquality) data(rfsrc_airq, package=\"ggRandomForests\") gg_dta <- gg_vimp(rfsrc_airq) plot(gg_dta)  ## -------- Boston data data(rfsrc_boston, package=\"ggRandomForests\") gg_dta <- gg_vimp(rfsrc_boston) plot(gg_dta)  ## -------- mtcars data data(rfsrc_mtcars, package=\"ggRandomForests\") gg_dta <- gg_vimp(rfsrc_mtcars) plot(gg_dta)  ## ------------------------------------------------------------ ## survival example ## ------------------------------------------------------------ ## -------- veteran data data(rfsrc_veteran, package=\"ggRandomForests\") gg_dta <- gg_vimp(rfsrc_veteran) plot(gg_dta)  ## -------- pbc data data(rfsrc_pbc, package=\"ggRandomForests\") gg_dta <- gg_vimp(rfsrc_pbc) plot(gg_dta)  } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/print.gg_minimal_depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a gg_minimal_depth object. — print.gg_minimal_depth","title":"Print a gg_minimal_depth object. — print.gg_minimal_depth","text":"Print gg_minimal_depth object.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/print.gg_minimal_depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a gg_minimal_depth object. — print.gg_minimal_depth","text":"","code":"# S3 method for class 'gg_minimal_depth' print(x, ...)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/print.gg_minimal_depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a gg_minimal_depth object. — print.gg_minimal_depth","text":"x gg_minimal_depth object. ... optional arguments","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/print.gg_minimal_depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print a gg_minimal_depth object. — print.gg_minimal_depth","text":"","code":"if (FALSE) { # \\dontrun{ ## ------------------------------------------------------------ ## classification example ## ------------------------------------------------------------ ## You can build a randomForest rfsrc_iris <- rfsrc(Species ~ ., data = iris) varsel_iris <- var.select(rfsrc_iris)  # Get a data.frame containing minimaldepth measures gg_dta <- gg_minimal_depth(varsel_iris) print(gg_dta)  ## ------------------------------------------------------------ ## regression example ## ------------------------------------------------------------ # ... or load a cached randomForestSRC object rfsrc_airq <- rfsrc(Ozone ~ ., data = airquality, na.action = \"na.impute\") varsel_airq <- var.select(rfsrc_airq)   # Get a data.frame containing minimaldepth measures gg_dta<- gg_minimal_depth(varsel_airq) print(gg_dta)  # To nicely print a rfsrc::var.select output... print(varsel_airq)   # ... or load a cached randomForestSRC object data(Boston, package=\"MASS\") rfsrc_boston <- randomForestSRC::rfsrc(medv~., Boston)  varsel_boston <- var.select(rfsrc_boston)  # Get a data.frame containing minimaldepth measures gg_dta<- gg_minimal_depth(varsel_boston) print(gg_dta)  # To nicely print a rfsrc::var.select output... print(varsel_boston) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/quantile_pts.html","id":null,"dir":"Reference","previous_headings":"","what":"Find points evenly distributed along the vectors values. — quantile_pts","title":"Find points evenly distributed along the vectors values. — quantile_pts","text":"function finds point values vector argument produce  groups intervals. Setting groups=2 return three values,  two end points, one mid point (median value vector). output can passed directly breaks argument cut function creating groups coplots.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/quantile_pts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find points evenly distributed along the vectors values. — quantile_pts","text":"","code":"quantile_pts(object, groups, intervals = FALSE)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/quantile_pts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find points evenly distributed along the vectors values. — quantile_pts","text":"object vector object values. groups many points want intervals return raw points intervals passed cut function","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/quantile_pts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find points evenly distributed along the vectors values. — quantile_pts","text":"vector groups+1 cut point values.","code":""},{"path":[]},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/quantile_pts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find points evenly distributed along the vectors values. — quantile_pts","text":"","code":"data(Boston, package=\"MASS\") rfsrc_boston <- randomForestSRC::rfsrc(medv~., Boston)  # To create 6 intervals, we want 7 points. # quantile_pts will find balanced intervals rm_pts <- quantile_pts(rfsrc_boston$xvar$rm, groups=6, intervals=TRUE)  # Use cut to create the intervals rm_grp <- cut(rfsrc_boston$xvar$rm, breaks=rm_pts)  summary(rm_grp) #> (3.56,5.73] (5.73,5.98] (5.98,6.21] (6.21,6.47] (6.47,6.87] (6.87,8.78]  #>          81          85          92          87          81          80"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/shift.html","id":null,"dir":"Reference","previous_headings":"","what":"lead function to shift by one (or more). — shift","title":"lead function to shift by one (or more). — shift","text":"lead function shift one ().","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"lead function to shift by one (or more). — shift","text":"","code":"shift(x, shift_by = 1)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"lead function to shift by one (or more). — shift","text":"x vector values shift_by integer length 1, giving number positions lead (positive) lag (negative) ","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/shift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"lead function to shift by one (or more). — shift","text":"Lead lag useful comparing values offset constant (e.g. previous next value) Taken : http://ctszkin.com/2012/03/11/generating--laglead-variables/ function allows remove dplyr::lead depends. Still suggest vignettes though.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"lead function to shift by one (or more). — shift","text":"","code":"d<-data.frame(x=1:15) #generate lead variable d$df_lead2<-ggRandomForests:::shift(d$x,2) #generate lag variable d$df_lag2<-ggRandomForests:::shift(d$x,-2)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/surface_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a set of (x, y, z) matrices for surface plotting a gg_partial_coplot object — surface_matrix","title":"Construct a set of (x, y, z) matrices for surface plotting a gg_partial_coplot object — surface_matrix","text":"Construct set (x, y, z) matrices surface plotting gg_partial_coplot object","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/surface_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a set of (x, y, z) matrices for surface plotting a gg_partial_coplot object — surface_matrix","text":"","code":"surface_matrix(dta, xvar)"},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/surface_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a set of (x, y, z) matrices for surface plotting a gg_partial_coplot object — surface_matrix","text":"dta gg_partial_coplot object containing least 3 numeric columns data xvar vector 3 column names data object, (x, y, z) order","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/surface_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a set of (x, y, z) matrices for surface plotting a gg_partial_coplot object — surface_matrix","text":"create surface plot, plot3D::surf3D function expects 3 matrices n.x n.y. Take p+1 n gg_partial_coplot object, extract construct x, y z matrices provided xvar column names.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/reference/surface_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a set of (x, y, z) matrices for surface plotting a gg_partial_coplot object — surface_matrix","text":"","code":"if (FALSE) { # \\dontrun{ ## From vignette(randomForestRegression, package=\"ggRandomForests\") data(Boston, package=\"MASS\") rfsrc_boston <- randomForestSRC::rfsrc(medv~., Boston)  varsel_boston <- var.select(rfsrc_boston)   rm_pts <- quantile_pts(rfsrc_boston$xvar$rm,     groups = 9,      intervals = TRUE)   partial_boston_surf <- lapply(rm_pts, function(ct) {   rfsrc_boston$xvar$rm <- ct   randomForestSRC::plot.variable(     rfsrc_boston,     xvar.names = \"lstat\",      time = 1,     npts = 10,     show.plots = FALSE,     partial = TRUE    )  })     # Instead of groups, we want the raw rm point values, # To make the dimensions match, we need to repeat the values # for each of the 50 points in the lstat direction rm.tmp <- do.call(c,lapply(rm_pts,                            function(grp) {rep(grp,                            length(partial_boston_surf))}))  # Convert the list of plot.variable output to partial_surf <- do.call(rbind,lapply(partial_boston_surf, gg_partial))  # attach the data to the gg_partial_coplot partial_surf$rm <- rm.tmp  # Transform the gg_partial_coplot object into a list of three named matrices # for surface plotting with plot3D::surf3D srf <- surface_matrix(partial_surf, c(\"lstat\", \"rm\", \"yhat\")) } # }  if (FALSE) { # \\dontrun{ # surf3D is in the plot3D package. library(plot3D) # Generate the figure. surf3D(x=srf$x, y=srf$y, z=srf$z, col=topo.colors(10),        colkey=FALSE, border = \"black\", bty=\"b2\",        shade = 0.5, expand = 0.5,        lighting = TRUE, lphi = -50,        xlab=\"Lower Status\", ylab=\"Average Rooms\", zlab=\"Median Value\" ) } # }"},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v240","dir":"Changelog","previous_headings":"","what":"ggRandomForests v2.4.0","title":"ggRandomForests v2.4.0","text":"Updating latest ggplot2 functions Utilize namespace referencing Added pkgdown documentation Minor testing improvements","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v230","dir":"Changelog","previous_headings":"","what":"ggRandomForests v2.3.0","title":"ggRandomForests v2.3.0","text":"Knocking dust . Fix ROC curves Fix colors VIMP plot","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v221","dir":"Changelog","previous_headings":"","what":"ggRandomForests v2.2.1","title":"ggRandomForests v2.2.1","text":"CRAN release: 2022-09-01 Fix docs HTML5/Roxygen update","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v220","dir":"Changelog","previous_headings":"","what":"ggRandomForests v2.2.0","title":"ggRandomForests v2.2.0","text":"CRAN release: 2022-05-09 Bring back regression vignette Improve package tests code coverage Clean code lintr","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v210","dir":"Changelog","previous_headings":"","what":"ggRandomForests v2.1.0","title":"ggRandomForests v2.1.0","text":"CRAN release: 2022-04-26 pull archive randomForestSRC 3.1 build release. Fixed plot bug gg_error show actual curve (issue 35)","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v201","dir":"Changelog","previous_headings":"","what":"ggRandomForests v2.0.1","title":"ggRandomForests v2.0.1","text":"CRAN release: 2016-09-07 Correct bug survival plots predicting future data without known outcome. Vignettes now https://github.com/ehrlinger/ggRFVignette tests moved https://github.com/ehrlinger/ggRFVignette Begin work rewriting checks use cached data. require runtime, hence run fewer CRAN release. Minor bug documentation fixes.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v200","dir":"Changelog","previous_headings":"","what":"ggRandomForests v2.0.0","title":"ggRandomForests v2.0.0","text":"CRAN release: 2016-06-11 Added initial support randomForest package Updated cache files randomForestSRC 2.2.0 release. Remove regression vignettes meet CRAN size limits. remain available package source https://github.com/ehrlinger/ggRandomForests Minor bug documentation fixes.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v121","dir":"Changelog","previous_headings":"","what":"ggRandomForests v1.2.1","title":"ggRandomForests v1.2.1","text":"CRAN release: 2015-12-12 Update cached datasets randomForestSRC 2.0.0 release. Correct vignette formatting errors (thanks Joe Smith)","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v120","dir":"Changelog","previous_headings":"","what":"ggRandomForests v1.2.0","title":"ggRandomForests v1.2.0","text":"CRAN release: 2015-11-15 Convert semantic versioning http://semver.org/ Updates release ggplot2 2.0.0 Change reshape2::melt dependence tidyr::gather Optimize tests CRAN optimize R CMD CHECK times.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v114","dir":"Changelog","previous_headings":"","what":"ggRandomForests v1.1.4","title":"ggRandomForests v1.1.4","text":"CRAN release: 2015-03-29 combine.gg_partial bug giving single variable plot.variable object. Remove dplyr depends transitions “Imports” “Suggests”. Argument single outcome gg_vimp plot classification forests. Improvements gg_vimp arguments consistency. Add bootstrap confidence intervals gg_rfsrc function. Initial partial.rfsrc function replace randomForestSRC::plot.variable function. Move cache data randomForestSRC v1.6.1 take advantage rfsrc version checking function calls. Vignette updates JSS submission “ggRandomForests: Exploring Random Forest Survival”. Vignette updates arXiv submission ggRandomForests: Random Forests Regression optimizations reduce package size. Remove tests CRAN build optimise R CMD CHECK times. Remove pdf vignette figure CRAN build. Return S3method calls NAMESPACE “S3 methods exported registered” R V3.2+. Misc Bug Fixes.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v113","dir":"Changelog","previous_headings":"","what":"ggRandomForests v1.1.3","title":"ggRandomForests v1.1.3","text":"CRAN release: 2015-01-08 Update “ggRandomForests: Visually Exploring Random Forest Regression” vignette. development draft package vignette “Survival Random Forests”. Rename vignettes align randomForestSRC package usage. Add tests example functions. Refactor gg_ functions S3 methods allow future implementation random forest packages. Improved help files. Updated DESCRIPTION file remove redundant parts. Misc Bug Fixes.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v112","dir":"Changelog","previous_headings":"","what":"ggRandomForests v1.1.2","title":"ggRandomForests v1.1.2","text":"CRAN release: 2014-12-25 Add package vignette “ggRandomForests: Visually Exploring Random Forest Regression” Add gg_partial_coplot, quantile_cuts surface_matrix functions export calc_roc calc_auc functions. replace tidyr function dependency reshape2 (melt instead gather) due lazy eval issues. reduce dplyr dependencies (remove select %>% usage base equivalents, still use tbl_df printing) development package vignette “Survival Random Forests” Refactor cached example datasets better documentation, estimates examples. Improved help files. Updated DESCRIPTION file remove redundant parts. Misc Bug Fixes.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v111","dir":"Changelog","previous_headings":"","what":"ggRandomForests v1.1.1","title":"ggRandomForests v1.1.1","text":"CRAN release: 2014-12-13 Maintenance release, mostly fix gg_survival gg_partial plots. * Fix gg_survival functions plot kaplan-meier estimates. * Fix gg_partial functions categorical variables. * Add S3 print functions. * Try make gg_functions consistent. * development package vignette “Survival Random Forests” * Modify example cached datasets better estimates examples. * Improve help files. * Misc Bug Fixes.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v110","dir":"Changelog","previous_headings":"","what":"ggRandomForests v1.1.0","title":"ggRandomForests v1.1.0","text":"CRAN release: 2014-12-05 Add panel option gg_variable gg_partial Rework interactions plot add gg_coplot functions Imports instead depends Add version dependencies randomForestSRC Include package vignette “Random Forests Survival” Misc Bug Fixes","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v100","dir":"Changelog","previous_headings":"","what":"ggRandomForests v1.0.0","title":"ggRandomForests v1.0.0","text":"CRAN release: 2014-10-15 First CRAN release.","code":""},{"path":"http://ehrlinger.github.io/ggRandomForests/news/index.html","id":"ggrandomforests-v02","dir":"Changelog","previous_headings":"","what":"ggRandomForests v0.2","title":"ggRandomForests v0.2","text":"Initial useR!2014 release.","code":""}]
